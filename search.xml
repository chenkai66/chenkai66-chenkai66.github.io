<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>区块链入门（五）合约编写实例补充</title>
    <url>/posts/a4c5a08d.html</url>
    <content><![CDATA[<font color="red"> 注：本教程为技术教程，不谈论且不涉及炒作任何数字货币 </font>

<h1 id="合约编写实战实例"><a href="#合约编写实战实例" class="headerlink" title="合约编写实战实例"></a>合约编写实战实例</h1><h2 id="一、简单代币合约"><a href="#一、简单代币合约" class="headerlink" title="一、简单代币合约"></a>一、简单代币合约</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt; <span class="number">0.4</span><span class="number">.22</span>;</span><br><span class="line"></span><br><span class="line">contract Coin&#123;</span><br><span class="line">    <span class="comment">//这里我们定义了一个address 作为key, uint做为value的hashTable balances; 我们还定义了一个address的变量minter;</span></span><br><span class="line">    address public minter;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span>=&gt;</span>uint) balances;</span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">//代表创建这个合约的账户地址，被赋值给变量minter.</span></span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个挖矿合约 </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == minter);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] &gt;= amount);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender,receiver,amount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：<br>上面实现一个简单的加密货币，币在这里可以无中生有，但只有创建合约的人才能做到，且任何人都可以给他人转币，无需注册名和密码。</p>
<p><code>address</code>类型是一个160位的值，不允许任何算数操作，这种类型适合存储合约地址或外部人员。</p>
<p><code>mappings</code>可看作是一个哈希表，它会执行虚拟初始化，以使得所有可能存在的键都映射到一个字节表示为全零的值。</p>
<p><code>event Sent(address from, address to, uint amount)</code>;声明了一个所谓的事件，它在send函数最后一行被发出。用户界面可以监听区块链上正在发送的事件，且不会花费太多成本，一旦它被发出，监听该事件的listener都将收到通知，而所有的事件都包含了<code>from</code>,<code>t</code>o和<code>amoun</code>t三个参数，可方便追踪事务。</p>
<p><code>msg.sender</code>始终是当前函数或者外部函数调用的来源地址。</p>
<p>最后真正被用户和其他合约所调用的，用于完成本合约功能的方法是<code>mint</code>和<code>send</code>。若<code>mint</code>被合约创建者外的其他调用则说明都不会发生。</p>
<p><code>send</code>函数可被任何人用于向其他人发送代币，前提是发送者拥有这些代币，若使用合约发送代币给一个地址，当在区块链浏览器上查到该地址时时看不到任何相关信息的，因为，实际上发送币和更改余额的信息仅仅存在特定合约的数据存储器中。通过使用事件，可非常简单地为新币创建一个区块链浏览器来追踪交易和余额。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-15.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>



<h2 id="二、水龙头合约"><a href="#二、水龙头合约" class="headerlink" title="二、水龙头合约"></a>二、水龙头合约</h2><p>在前面我们通过 Ropsten 测试网络的水龙头（Faucet）获取了一些以太币，并提到可以向水龙头账户发送以太币来捐赠以太币。实际上，水龙头账户是一个合约账户，水龙头就是一份合约，而整个网站就是合约+前端组成的DApp。下面我们通过 Remix 来编写一个简单的水龙头合约，借此了解如何创建、部署合约以及一些 Solidity 的基本语法。</p>
<p>首先打开 Remix，并新建一个名为 faucet.sol 的文件，该文件就是 Solidity 的源文件</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-16.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>

<p>打开 faucet.sol，并写入如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract faucet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span> (<span class="params">uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span> (amount &lt;= <span class="number">1e18</span>);</span><br><span class="line">        msg.sender.transfer (amount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    receive () external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这几行代码我们就实现了一个非常简单的水龙头合约。首行代码 <code>pragma solidity ^0.7.0</code>是一个<strong>杂注</strong>，指定了我们的源文件使用的编译器版本不能低于 0.7.0，也不能高于 0.8.0。</p>
<p><code>contract faucet{...}</code> 声明了一个合约对象，合约对象类似面向对象语言中的类，对象名必须跟文件名相同。</p>
<p>接下来通过  <code>function withdraw (uint amount) public {...}</code> 创建了一个名为  withdraw 的函数，该函数接收一个无符号整数（uint）作为参数，并且被声明为 public 函数，意为可以被其他合约调用。</p>
<p>withdraw 函数体中的 <code>require</code> 是 Solidity 的内置函数，用来检测括号中的条件是否满足。条件满足则继续执行合约，条件不满足则合约停止执行，回撤所有执行过的操作，并抛出异常。在这里我们通过 <code>require (amount &lt;= 1e18)</code> 来检测输入的以太币值是否小于等于1个以太。</p>
<p>接下来的这一行 <code>msg.sender.transfer (amount)</code> 就是实际的提款操作了。<code>msg</code> 是 Solidity 中内置的对象，所有合约都可以访问，它代表触发此合约的交易。也就是说当我们调用 <code>withdraw</code> 函数的时候实际上触发了一笔交易，并用 <code>msg</code> 来表示它。<code>sender</code> 是交易 <code>msg</code> 的属性，表示了交易的发件人地址。函数 <code>transfer</code> 是一个内置函数，它接收一个参数作为以太币的数量，并将该数量的以太币从合约账户发送到调用合约的用户的地址中。</p>
<p>最后一行是一个特殊的函数 <code>receive</code> ，这是所谓的 <code>fallback</code> 或 <code>default</code> 函数。当合约中的其他函数无法处理发送到合约中的交易信息时，就会执行该函数。在这里，我们将该函数声明为 <code>external</code> 和 <code>payable</code> ，<code>external</code> 意味着该函数可以接收来自外部账户的调用，<code>payable</code> 意味着该函数可以接收来自外部账户发送的以太币。</p>
<p>这样，当我们调用合约中的 <code>withdraw</code> 并提供一个参数时，我们可以从这份合约中提出以太币；当我们向合约发送以太币时，就会调用 <code>receive</code> 函数往合约中捐赠以太币。</p>
<p>代码编写完毕后，在 Remix 左侧的功能栏中选择第二项，并点击 <em>Compile faucet.sol</em> 来编译我们的 sol 文件。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-17.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>编译完成后会出现一个 Warning，提示我们添加 SPDX license，可以忽略。</p>
<p>随后选择 Remix 左侧工具栏的第三项，进入合约部署界面</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-18.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>首先将 ENVIRONMENT 选择为 Injected Web3，这样才能通过 MetaMask 钱包来发送交易。</p>
<p>随后点击 Deploy 部署合约，MetaMask 会弹出部署合约的交易界面</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-19.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>因为该笔交易是合约创建交易，因此我们支付的以太币为0，但仍需支付一定的 Gas 费用，可以自己设定 Gas 的价格。</p>
<p>合约部署成功后会收到 Chrome 的消息提示，并在 Remix 的 Deployed Contracts 中也会有显示</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-20.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>这样我们就完成了这个水龙头合约的部署。</p>
<h4 id="水龙头测试"><a href="#水龙头测试" class="headerlink" title="水龙头测试"></a>水龙头测试</h4><p>我们刚刚创建的水龙头中还没有以太坊，因此我们可以通过 MetaMask 向水龙头合约的地址中发送一些以太坊。水龙头合约的地址会显示在 Remix 中的，见上图 FAUCET AT 0X7A4…34219，可以直接复制。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-21.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>交易被确认后，我们的水龙头中就有了0.999726个以太币，现在我们可以通过 Remix 中合约一栏的 withdraw 按钮来提取以太币了。需要注意，这里输入的以太币个数是以 wei 为单位的。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-22.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>点击 withdraw 后，会弹出警告框</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-23.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>这是因为目前我们还没有设置这笔交易的 Gas，不用担心，点击 Send Transaction 后，在弹出的 MetaMask 中设置即可。</p>
<p>交易被确认后，我们得到了刚刚提取的0.999726个以太币</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-15.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>


<p>若大家没有执行成功可以重新做一次、查找其他资料或者<a href="https://www.bilibili.com/video/BV1sJ411D72u?p=465" target="_blank" rel="noopener">观看此视频</a></p>
<h2 id="三、投票合约的实现"><a href="#三、投票合约的实现" class="headerlink" title="三、投票合约的实现"></a>三、投票合约的实现</h2><p><img src="\Pic\Blockchain_Pic\rating.png" style="zoom:67%;"></p>
<p>本次教程将以一个较复杂的投票合约作为结束，我们希望实现的功能是为每个（投票）建议建立一份合约,然后作为合约的创造者-主席，主席将赋予每个成员(地址)投票权，而成员的投票权可以选择委托给其他人也可以自己投票，结束时将返回投票最多的提案。听起来很简单一个功能实现起来却较为复杂，下面我们拆分开进行讲解</p>
<p>注：</p>
<ol>
<li>代码可直接在Remix编辑器的已有solidity文件中找到,在contract/_Ballot.sol文件里</li>
<li>若学习者前面部分掌握较牢固，不妨尝试直接自行阅读代码，无需阅读本节内容</li>
</ol>
<p>首先我们定义成员类型，我们为每个投票者定义权重、是否已投票、</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Voter &#123;</span><br><span class="line">    uint weight; <span class="comment">// weight is accumulated by delegation</span></span><br><span class="line">    bool voted;  <span class="comment">// if true, that person already voted</span></span><br><span class="line">    address delegate; <span class="comment">// person delegated to</span></span><br><span class="line">    uint vote;   <span class="comment">// index of the voted proposal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们定义提案类型，包含提案名和投票总数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">struct Proposal &#123;</span><br><span class="line">    bytes32 name;   <span class="comment">// short name (up to 32 bytes)</span></span><br><span class="line">    uint voteCount; <span class="comment">// number of accumulated votes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义三个变量，主席是一个公开的地址，建立投票者与地址的映射，然后定义提案动态数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">address public chairperson;</span><br><span class="line">mapping(<span class="function"><span class="params">address</span> =&gt;</span> Voter) public voters;</span><br><span class="line">Proposal[] public proposals;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>address public chairperson</code>：投票发起人，类型为 address。</li>
<li><code>mapping(address =&gt; Voter) public voters</code>：所有投票人，类型为 <code>address</code> 到 <code>Voter</code> 的映射。</li>
<li><code>Proposal[] public proposals</code>：所有提案，类型为动态大小的 <code>Proposal</code> 数组。</li>
</ul>
<p>3 个状态变量都使用了 <code>public</code> 关键字，使得变量可以被外部访问（即通过消息调用）。事实上，编译器会自动为 <code>public</code>的变量创建同名的 <code>getter</code> 函数，供外部直接读取。</p>
<p>我们还需要为每个投票赋予初始权值，并将主席的权重设置为1。我们一般使用<code>constructor</code>赋初值，这与C++等语言类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(bytes32[] memory proposalNames) &#123;</span><br><span class="line">    chairperson = msg.sender;</span><br><span class="line">    voters[chairperson].weight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; proposalNames.length; i++) &#123;</span><br><span class="line">        proposals.push(Proposal(&#123;</span><br><span class="line">            name: proposalNames[i],</span><br><span class="line">            voteCount: <span class="number">0</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有提案的名称通过参数 <code>bytes32[] proposalNames</code> 传入，逐个记录到状态变量 <code>proposals</code> 中。同时用 <code>msg.sender</code> 获取当前调用消息的发送者的地址，记录为投票发起人 <code>chairperson</code>，该发起人投票权重设为 1。</p>
<p>接下来我们需要给每个投票者赋予权重：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveRightToVote</span>(<span class="params">address voter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(</span><br><span class="line">        msg.sender == chairperson,</span><br><span class="line">        <span class="string">"Only chairperson can give right to vote."</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">require</span>(</span><br><span class="line">        !voters[voter].voted,</span><br><span class="line">        <span class="string">"The voter already voted."</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">require</span>(voters[voter].weight == <span class="number">0</span>);</span><br><span class="line">    voters[voter].weight = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数给 <code>address voter</code> 赋予投票权，即将 <code>voter</code> 的投票权重设为 1，存入 <code>voters</code> 状态变量。</p>
<p>上面这个函数只有投票发起人 <code>chairperson</code> 可以调用。这里用到了 <code>require((msg.sender == chairperson) &amp;&amp; !voters[voter].voted)</code> 函数。如果<code>require</code> 中表达式结果为 <code>false</code>，这次调用会中止，且回滚所有状态和以太币余额的改变到调用前。但已消耗的 <code>Gas</code> 不会返还。</p>
<p>下面一段是整段代码的重点，其作用是委托其他人代理投票，基本思路是：</p>
<ol>
<li>使用<code>require</code>判断委托人是否已投票（若投过票再委托则重复投票），并判断被委托对象是否是自己</li>
<li>当判断被委托人不是0地址（主席）时，被委托人代理委托人的票，【绕口警告】由于被委托人也可能委托了别人，因此这里需要一直循环直到找到最后没有委托别人的被委托人为止！</li>
<li>委托人找到对应的被委托人，委托人已投票（避免重复投票）</li>
<li>判断被委托人是否已投票，若投了票则将被委托人投的提案票数加上委托人的权重，若未投票则令被委托人的权重加上委托人的权重（以后投票自然相当于投两票）</li>
</ol>
<p>注：该函数使用了 <code>while</code> 循环，这里合约编写者需要十分谨慎，防止调用者消耗过多 <code>Gas</code>，甚至出现死循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">address to</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    Voter storage sender = voters[msg.sender];</span><br><span class="line">    <span class="built_in">require</span>(!sender.voted, <span class="string">"You already voted."</span>);</span><br><span class="line">    <span class="built_in">require</span>(to != msg.sender, <span class="string">"Self-delegation is disallowed."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (voters[to].delegate != address(<span class="number">0</span>)) &#123;</span><br><span class="line">    	to = voters[to].delegate;</span><br><span class="line">    	<span class="built_in">require</span>(to != msg.sender, <span class="string">"Found loop in delegation."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sender.voted = <span class="literal">true</span>;</span><br><span class="line">    sender.delegate = to;</span><br><span class="line">    Voter storage delegate_ = voters[to];</span><br><span class="line">    <span class="keyword">if</span> (delegate_.voted) &#123;</span><br><span class="line">    	proposals[delegate_.vote].voteCount += sender.weight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	delegate_.weight += sender.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>投票部分仅是几个简单的条件判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vote</span>(<span class="params">uint proposal</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        Voter storage sender = voters[msg.sender];</span><br><span class="line">        <span class="built_in">require</span>(sender.weight != <span class="number">0</span>, <span class="string">"Has no right to vote"</span>);</span><br><span class="line">        <span class="built_in">require</span>(!sender.voted, <span class="string">"Already voted."</span>);</span><br><span class="line">        sender.voted = <span class="literal">true</span>;</span><br><span class="line">        sender.vote = proposal;</span><br><span class="line">        proposals[proposal].voteCount += sender.weight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>voters[msg.sender]</code> 获取投票人，即此次调用的发起人。接下来检查是否是重复投票，如果不是，进行投票后相关状态变量的更新。</p>
<p>接下来是计算获胜提案:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">winningProposal</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint winningProposal_</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint winningVoteCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint p = <span class="number">0</span>; p &lt; proposals.length; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proposals[p].voteCount &gt; winningVoteCount) &#123;</span><br><span class="line">            winningVoteCount = proposals[p].voteCount;</span><br><span class="line">            winningProposal_ = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>returns (uint winningProposal)</code> 指定了函数的返回值类型，<code>constant</code> 表示该函数不会改变合约状态变量的值。</p>
<p>最后是查询获胜者名称：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">winnerName</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bytes32 winnerName_</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    winnerName_ = proposals[winningProposal()].name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里采用内部调用 <code>winningProposal()</code> 函数的方式获得获胜提案。如果需要采用外部调用，则需要写为 <code>this.winningProposal()</code>。</p>
<p><strong>参考自：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1sJ411D72u" target="_blank" rel="noopener">尚硅谷区块链全套Go语言→GoWeb→以太坊→项目实战</a><br><a href="http://cw.hubwiz.com/card/c/web3.js-1.0/" target="_blank" rel="noopener">web3.js 1.0中文手册</a></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>区块链入门（四）web3js</title>
    <url>/posts/5521455b.html</url>
    <content><![CDATA[<font color="red">注：本教程为技术教程，不谈论且不涉及炒作任何数字货币 </font>

<h2 id="一、以太坊客户端"><a href="#一、以太坊客户端" class="headerlink" title="一、以太坊客户端"></a>一、以太坊客户端</h2><h3 id="1-1、什么是以太坊客户端"><a href="#1-1、什么是以太坊客户端" class="headerlink" title="1.1、什么是以太坊客户端"></a>1.1、什么是以太坊客户端</h3><ul>
<li>以太坊客户端是一个软件应用程序，它实现以太坊规范并通过p2p网络与其他以太坊客户端进行通信。如果不同的以太坊客户端符合参考规范和标准化通信协议，则可以进行相互操作。</li>
<li>以太坊是一个开源项目，由“黄皮书”正式规范定义。除了各种以太坊改进提案之外，此正式规范还定义了以太坊客户端的标准行为。</li>
<li>因为以太坊有明确的正式规范，以太网客户端有了许多独立开发的软件实现，它们之间又可以彼此交互。</li>
</ul>
<h3 id="1-2、基于以太坊规范的网络"><a href="#1-2、基于以太坊规范的网络" class="headerlink" title="1.2、基于以太坊规范的网络"></a>1.2、基于以太坊规范的网络</h3><ul>
<li>存在各种基于以太坊规范的网络，这些网络基本符合以太坊“黄皮书”中定义的形式规范，但它们之间可能相互也可能不相互操作。</li>
<li>这些基于以太坊的网络中有：以太坊，以太坊经典，Ella，Expanse，Ubiq，Musicoin等等。</li>
<li>虽然大多数在协议级别兼容，但这些网络通常具有特殊要求，以太坊客户端软件的维护人员、需要进行微小更改、以支持每个网络的功能或属性</li>
</ul>
<h3 id="1-3、太坊的多种客户端"><a href="#1-3、太坊的多种客户端" class="headerlink" title="1.3、太坊的多种客户端"></a>1.3、太坊的多种客户端</h3><ul>
<li><a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">go-ethereum ( Go )</a><br>官方推荐，开发使用最多</li>
<li>parity ( Rust )<br>最轻便客户端，在历次以太坊网络攻击中表现卓越</li>
<li><p>cpp-ethereum (C++)</p>
</li>
<li><p>pyethapp (python)</p>
</li>
<li><p>ethereumjs-lib ( javascript )</p>
</li>
<li><p>EthereumJ / Harmony ( Java )</p>
</li>
</ul>
<h3 id="1-4、以太坊全节点"><a href="#1-4、以太坊全节点" class="headerlink" title="1.4、以太坊全节点"></a>1.4、以太坊全节点</h3><ul>
<li>全节点是整个主链的一个副本，存储并维护链上的所有数据，并随时验证新区块的合法性。</li>
<li>区块链的健康和扩展弹性，取决于具有许多独立操作和地理上分散的全节点。每个全节点都可以帮助其他新节点获取区块数据，并提供所有交易和合约的独立验证。</li>
<li>运行全节点将耗费巨大的成本，包括硬件资源和带宽。</li>
<li>以太坊开发不需要在实时网络（主网）上运行的全节点。我们可以使用测试网络的节点来代替，也可以用本地私链，或者使用服务商提供的基于云的以太坊客户端；这些几乎都可以执行所有操作。</li>
</ul>
<h3 id="1-5、远程客户端和轻节点"><a href="#1-5、远程客户端和轻节点" class="headerlink" title="1.5、远程客户端和轻节点"></a>1.5、远程客户端和轻节点</h3><ul>
<li><p>远程客户端</p>
<p>不存储区块链的本地副本或验证块和交易。这些客户端一般只提供钱包的功能，可以创建和广播交易。远程客户端可用于连接到现有网络，MetaMask 就是一个这样的客户端。</p>
</li>
<li><p>轻节点</p>
<p>  不保存链上的区块历史数据，只保存区块链当前的状态。轻节点可以对块和交易进行验证。</p>
</li>
</ul>
<ul>
<li><p>全节点的优缺点</p>
<ul>
<li>优点<ul>
<li>为以太坊网络的灵活性和抗审查性提供有力支持</li>
<li>权威地验证所有交易</li>
<li>可以直接与公众区块链上的任何合约交互</li>
<li>可以离线查询区块链状态（账户、合约等）</li>
<li>可以直接把自己的合约部署到公共区块链中</li>
</ul>
</li>
<li>缺点<ul>
<li>需要巨大的硬件和带宽资源，而且会不断增长</li>
<li>第一次下载往往需要几天才能完全同步</li>
<li>必须及时维护、升级并保持在线状态以同步区块</li>
</ul>
</li>
</ul>
<h5 id="公共测试网络节点的优缺点"><a href="#公共测试网络节点的优缺点" class="headerlink" title="公共测试网络节点的优缺点"></a>公共测试网络节点的优缺点</h5><ul>
<li>优点<ul>
<li>一个testnet节点需要同步和存储更少的数据，大约10GB，具体取决于不同的网络</li>
<li>一个testnet节点一般可以在几个小时内完成同步</li>
<li>部署合约或进行交易只需要发送测试以太，可以从”水龙头“免费获得</li>
<li>测试网络是公共区块链，有许多其他用户和合约运行（区别于私链）</li>
</ul>
</li>
<li>缺点<ul>
<li>测试网络上使用测试以太没有价值。因此无法测试交易对手的安全性，因为没有任何利害关系</li>
<li>测试网络上的测试无法涵盖所有真实主网特性。例如：交易费用虽然是发送交易所必需的，但由于gas免费，因此 testnet上往往不会考虑。而且一般来说，测试网络不会像主网一样经常拥堵</li>
</ul>
</li>
</ul>
<h5 id="本地私链的优缺点"><a href="#本地私链的优缺点" class="headerlink" title="本地私链的优缺点"></a>本地私链的优缺点</h5><ul>
<li>优点<ul>
<li>磁盘上几乎没有数据，也不同步别的数据，是一个完全干净的环境</li>
<li>无需获取测试以太，可以分配任意以太，也可以随时自己挖矿获得</li>
<li>没有其他用户与合约，无外部干扰</li>
</ul>
</li>
<li>缺点<ul>
<li>没有其他用户意味与公链的行为不同，发送的交易并不存在空间或交易顺序的竞争</li>
<li>除自己之外没有矿工意味着挖矿更容易预测，因此无法测试公链上发生的某些情况</li>
<li>没有其他合约意味着必须部署要测试的所有内容，包括所有的依赖项和合约库</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们的教程主要基于本地私链的搭建，以后的交易等也主要基于我们的私链，因此以太坊客户端及私链的搭建在我们本次学习中至关重要。</p>
<p><strong>JSON-RPC</strong></p>
<ul>
<li>以太坊客户端提供了API 和一组远程调用（RPC）命令，这些命令被编码为 JSON。这被称为 JSON-RPC API。本质上，JSON-RPCAPI 就是一个接口，允许我们编写的程序使用以太坊客户端作为网关，访问以太坊网络和链上数据。</li>
<li>通常，RPC 接口作为一个 HTTP 服务，端口设定为 8545。出于安全原因，默认情况下，它仅限于接受来自localhost 的连接。</li>
<li>要访问JSON-RPC API，我们可以使用编程语言编写的专用库，例如JavaScript的 web3.js。</li>
<li>或者也可以手动构建HTTP请求并发送/接收JSON编码的请求，如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -X POST -H <span class="string">"Content-Type:application/json"</span> --data <span class="string">'&#123;"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1&#125;'</span> http:<span class="comment">//127.0.0.1:8545</span></span><br></pre></td></tr></table></figure>
<h2 id="二、用-Geth-搭建以太坊私链"><a href="#二、用-Geth-搭建以太坊私链" class="headerlink" title="二、用 Geth 搭建以太坊私链"></a>二、用 Geth 搭建以太坊私链</h2><h3 id="2-1安装-go"><a href="#2-1安装-go" class="headerlink" title="2.1安装 go"></a>2.1安装 go</h3><p>大家首先输入<code>go version</code>查看自己是否配置成功go环境，若不成功参考下面博客：</p>
<p><a href="https://blog.csdn.net/qq_44702847/article/details/108597386" target="_blank" rel="noopener">go ： GoLand安装及环境配置</a></p>
<p>若成功则如下图所示</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-1.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 1</div>
</center>



<h3 id="2-2-安装-Geth"><a href="#2-2-安装-Geth" class="headerlink" title="2.2 安装 Geth"></a>2.2 安装 Geth</h3><p>安装 Geth 有很多种方式，这里主要就 Linux 环境给出两种方法：系统包管理器（apt-get）安装和源码安装。更加推荐大家用源码安装，在整个过程中可以看到 Geth 各组件的构建步骤。</p>
<p>其他OS安装方法见<a href="https://geth.ethereum.org/docs/install-and-build/installing-geth" target="_blank" rel="noopener">本教程</a></p>
<p><strong>方法一、apt-get</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install ethereum</span><br></pre></td></tr></table></figure>
<p><strong>方法二、源码安装</strong></p>
<ol>
<li>克隆 github 仓库我们的第一步是克隆 git 仓库，以获取源代码的副本。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/ethereum/go-ethereum.git</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从源码构建 Geth要构建 Geth，切换到下载源代码的目录并使用 make 命令：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd go-ethereum</span><br><span class="line">make geth</span><br></pre></td></tr></table></figure>
<p>如果一切顺利，我们将看到 Go 编译器构建每个组件，直到它生成 geth 可执行文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">build/env.sh go run build/ci.go install ./cmd/geth</span><br><span class="line">&gt;&gt;&gt; <span class="regexp">/usr/</span>local/go/bin/go install -ldflags -X</span><br><span class="line">main.gitCommit=<span class="number">58</span>a1e13e6dd7f52a1d5e67bee47d23fd6cfdee5c -v ./cmd/geth</span><br><span class="line">github.com/ethereum/go-ethereum/common/hexutil</span><br><span class="line">github.com/ethereum/go-ethereum/common/math</span><br><span class="line">github.com/ethereum/go-ethereum/crypto/sha3 github.com/ethereum/go-ethereum/rlp</span><br><span class="line">github.com/ethereum/go-ethereum/crypto/secp256k1</span><br><span class="line">github.com/ethereum/go-ethereum/common [...]</span><br><span class="line">github.com/ethereum/go-ethereum/cmd/utils</span><br><span class="line">github.com/ethereum/go-ethereum/cmd/geth Done building. Run <span class="string">"build/bin/geth"</span> to</span><br><span class="line">launch geth.</span><br></pre></td></tr></table></figure>
<p> 查看 geth version，确保在真正运行之前安装正常：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-2.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 2</div>
</center>



<h3 id="启动节点同步"><a href="#启动节点同步" class="headerlink" title="启动节点同步"></a>启动节点同步</h3><p>安装好了 Geth，现在我们可以尝试运行一下它。执行下面的命令，geth 就会开始同步区块，并存储在当前目录下。</p>
<p>这里的 —syncmode fast 参数表示我们会以“快速”模式同步区块。在这种模式下，我们只会下载每个区块头和区块体，但不会执行验证所有的交易，直到所有区块同步完毕再去获取一个系统当前的状态。这样就节省了很多交易验证的时间。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">geth –datadir . --syncmode fast</span><br></pre></td></tr></table></figure>
<p>—datadir：后面的参数是区块数据及秘钥存放目录</p>
<p>通常，在同步以太坊区块链时，客户端会一开始就下载并验证每个块和每个交易，也就是说从创世区块开始。 毫无疑问，如果我们不加 —syncmode fast 参数，同步将花费很长时间并且具有很高的资源要求（它将需要更多的 RAM，如果你没有快速存储，则需要很长时间）。有些文章会把这个参数写成 —fast，这是以前快速同步模式的参数写法，现在已经被 –syncmode fast取代。如果我们想同步测试网络的区块，可以用下面的命令：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">geth --testnet --datadir . --syncmode fast</span><br></pre></td></tr></table></figure>
<p>—testnet 这个参数会告诉 geth 启动并连接到最新的测试网络，也就是 Ropsten。测试网络的区块和交易数量会明显少于主网，所以会更快一点。但即使是用快速模式同步测试网络，也会需要几个小时的时间</p>
<h3 id="2-3-搭建自己的私有链"><a href="#2-3-搭建自己的私有链" class="headerlink" title="2.3 搭建自己的私有链"></a>2.3 搭建自己的私有链</h3><p>因为公共网络的区块数量太多，同步耗时太长，我们为了方便快速了解 Geth，可以试着用它来搭一个只属于自己的私链。首先，我们需要创建网络的“创世”（genesis）状态，这写在一个小小的 JSON 文件里（例如，我们将其命名为 genesis.json，保存到当前目录下）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"config"</span>: &#123;</span><br><span class="line">    <span class="string">"chainId"</span>: <span class="number">15</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="string">"difficulty"</span>: <span class="string">"2000"</span>,</span><br><span class="line"><span class="string">"gasLimit"</span>: <span class="string">"2100000"</span>,</span><br><span class="line"><span class="string">"alloc"</span>: &#123;</span><br><span class="line">    <span class="string">"7df9a875a174b3bc565e6424a0050ebc1b2d1d82"</span>: &#123;   <span class="string">"balance"</span>: <span class="string">"300000"</span> &#125;,</span><br><span class="line">    <span class="string">"f41c74c9ae680c1aa78f42e5647a62f353b7bdde"</span>: &#123; <span class="string">"balance"</span>: <span class="string">"400000"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>genesis.json介绍</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-3.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 3</div>
</center>



<p>要创建一条以它作为创世块的区块链，我们可以使用下面的命令：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">geth --datadir . init genesis.json</span><br></pre></td></tr></table></figure>
<p>初始化完成后目录下多了geth和keystore两个文件夹：</p>
<ul>
<li>geth：保存该链上的区块数据</li>
<li>keystore：保存该链上的账户信息</li>
</ul>
<p><strong>可能遇到问题</strong>：</p>
<ul>
<li><p>Fatal: invalid genesis file: missing 0x prefix for hex data：这个错误信息意思很明白，就是你的json文件中，对于16进制数据，需要加上0x前缀</p>
</li>
<li><p>Fatal: invalid genesis file: hex string has odd length: 从Geth 1.6版本开始，设置的十六进制数值，不能是奇数位， 比如不能是0x0，而应该是0x00。</p>
</li>
<li><p>Fatal: failed to write genesis block: genesis has no chain configuration ：这个错误信息，就是说，你的配置文件中，缺少config部分。</p>
</li>
<li><p>Error: invalid sender: 这个错误虽然不会导致私有链初始化时出现失败的情况，但是会在以后的转账（web3.eth.sendTransaction），或者部署智能合约的时候产生。解决方法就是chainId 不能设置为0。 如果你完全按照Geth官方文档上给出的配置文件进行配置，就会产生这个错误。</p>
</li>
</ul>
<p>在当前目录下运行 geth，就会启动这条私链，注意要将 networked 设置为与创世块配置里的chainId 一致。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单开启</span></span><br><span class="line">(base) haobo@haobo:~<span class="regexp">/home/m</span>nt/bitcoin/test$ geth --datadir . --networkid <span class="number">150</span> --nodiscover <span class="built_in">console</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更一般的形式</span></span><br><span class="line">(base) haobo@haobo:~<span class="regexp">/home/m</span>nt/bitcoin/test$ geth --networkid <span class="number">150</span> --datadir <span class="string">"."</span> --identity <span class="string">"kexin"</span> --rpc --rpcport <span class="string">"8545"</span> --rpcaddr <span class="string">"localhost"</span> --port <span class="string">"30303"</span> --nodiscover --allow-insecure-unlock --rpcapi <span class="string">"eth,net,web3,personal,admin,shh,txpool,debug,miner"</span> <span class="built_in">console</span></span><br></pre></td></tr></table></figure>
<p>参数含义：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-4.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 4</div>
</center>



<p>我们可以看到节点正常启动：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-5.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 5</div>
</center>


<p>启动完之后，就可以通过<code>admin.nodeInfo.protocols.eth</code>来获取到刚启动的节点的一些信息（如下），比较上文初始化的配置，相关内容是一致的。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-6.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 6</div>
</center>


<p>恭喜！我们已经成功启动了一条自己的私链。</p>
<h2 id="3、Geth-控制台命令"><a href="#3、Geth-控制台命令" class="headerlink" title="3、Geth 控制台命令"></a>3、Geth 控制台命令</h2><p><code>Geth Console</code> 是一个交互式的 JavaScript 执行环境，其中 &gt; 是命令提示符,里面内置了一些用来操作以太坊的 JavaScript对象，我们可以直接调用这些对象来获取区块链上的相关信息。</p>
<p><strong>这些对象主要包括：</strong></p>
<ul>
<li>eth：主要包含对区块链进行访问和交互相关的方法；</li>
<li>net：主要包含查看 p2p 网络状态的方法；</li>
<li>admin：主要包含与管理节点相关的方法；</li>
<li>miner：主要包含挖矿相关的一些方法；</li>
<li>personal：包含账户管理的方法；</li>
<li>txpool：包含查看交易内存池的方法；</li>
<li>web3：包含以上所有对象，还包含一些通用方法。</li>
</ul>
<p><strong>常用命令有：</strong></p>
<ul>
<li>personal.newAccount()：创建账户；</li>
<li>personal.unlockAccount()：解锁账户；</li>
<li>eth.accounts：枚举系统中的账户；</li>
<li>eth.getBalance()：查看账户余额，返回值的单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的聪，1 ether = 10^18 Wei）；</li>
<li>eth.blockNumber：列出区块总数；</li>
<li>eth.getTransaction()：获取交易；</li>
<li>eth.getBlock()：获取区块；</li>
<li>miner.start()：开始挖矿；</li>
<li>miner.stop()：停止挖矿；</li>
<li>web3.fromWei()：Wei 换算成以太币；</li>
<li>web3.toWei()：以太币换算成 Wei；</li>
<li>txpool.status：交易池中的状态；</li>
<li>admin.addPeer()：连接到其他节点</li>
</ul>
<h3 id="3-1-操作测试"><a href="#3-1-操作测试" class="headerlink" title="3.1 操作测试"></a>3.1 操作测试</h3><p><strong>3.1.1 创建账户</strong></p>
<p>进入控制台后，可以通过使用命令来与私有链进行交互。创建一个新的账户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">Passphrase:</span><br><span class="line">Repeat passphrase:</span><br><span class="line"><span class="string">"0xc8248c7ecbfd7c4104923275b99fafb308bbff92"</span></span><br></pre></td></tr></table></figure>
<p>输入两遍密码后，生成账户地址。以同样的方式，可创建多个账户，查看账户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; eth.accounts</span><br></pre></td></tr></table></figure>
<p>查看账户余额</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[<span class="number">0</span>])</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-7.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 7</div>
</center>


<p><strong>3.1.2 挖矿</strong></p>
<p>启动挖矿：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; miner.start(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>其中 <code>start</code> 的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的 <code>DAG</code>文件，这个过程有点慢，等进度达到 100% 后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p>
<p>停止挖矿，在 控制台 中输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; miner.stop()</span><br></pre></td></tr></table></figure>
<p>挖到一个区块会奖励以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做 coinbase，默认情况下 coinbase 是本地账户中的第一个账户，可以通过 miner.setEtherbase() 将其他账户设置成 coinbase。</p>
<p>可以使用以下命令，当新区块挖出后，挖矿即可结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; miner.start(<span class="number">1</span>);admin.sleepBlocks(<span class="number">1</span>);miner.stop();</span><br></pre></td></tr></table></figure>
<p><strong>3.1.3 交易</strong></p>
<p>目前，账户 0 已经挖到了 3 个块的奖励，账户 1 的余额还是0：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[<span class="number">0</span>])</span><br><span class="line"><span class="number">15000000000000000000</span></span><br><span class="line">&gt; eth.getBalance(eth.accounts[<span class="number">1</span>])</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>我们要从账户 0 向账户 1 转账，先解锁账户 0，才能发起交易：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[<span class="number">0</span>])</span><br><span class="line">Unlock account <span class="number">0x3443ffb2a5ce3f4b80080791e0fde16a3fac2802</span></span><br><span class="line">Passphrase: </span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>发送交易，账户 0 -&gt; 账户 1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; amount = web3.toWei(<span class="number">5</span>,<span class="string">'ether'</span>)</span><br><span class="line"><span class="string">"5000000000000000000"</span></span><br><span class="line">&gt; eth.sendTransaction(&#123;<span class="attr">from</span>:eth.accounts[<span class="number">0</span>],<span class="attr">to</span>:eth.accounts[<span class="number">1</span>],<span class="attr">value</span>:amount&#125;)</span><br><span class="line">INFO [<span class="number">09</span><span class="number">-12</span>|<span class="number">07</span>:<span class="number">38</span>:<span class="number">12</span>] Submitted transaction                    fullhash=<span class="number">0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce</span> recipient=<span class="number">0x02bee2a1582bbf58c42bbdfe7b8db4685d4d4c62</span></span><br><span class="line"><span class="string">"0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce"</span></span><br></pre></td></tr></table></figure>
<p>此时如果没有挖矿，用 <code>txpool.status</code> 命令可以看到本地交易池中有一个待确认的交易，可以使用 <code>eth.getBlock(&quot;pending&quot;, true).transactions</code>查看当前待确认交易。使用下面命令开始挖矿。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;miner.start(<span class="number">1</span>);admin.sleepBlocks(<span class="number">1</span>);miner.stop();</span><br></pre></td></tr></table></figure>
<p>新区块挖出后，挖矿结束，查看账户 1 的余额，已经收到了账户 0 的以太币：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; web3.fromWei(eth.getBalance(eth.accounts[<span class="number">1</span>]),<span class="string">'ether'</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.1.3 查看交易和区块</strong></p>
<p>查看当前区块总数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; eth.blockNumber</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>通过区块号查看区块：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; eth.getBlock(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>通过交易 Hash 查看交易（Hash 值包含在上面交易返回值中）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;  eth.getTransaction(<span class="string">"0x9f5e61f3d686f793e2df6378d1633d7a9d1df8ec8c597441e1355112d102a6ce"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>3.1.3 其他节点加入</strong></p>
<p>此时，私有链已经通过该节点创建好了，如果其他节点想加入，需要通过以太坊客户端连接到该私有区块网络，并连接该网络的节点来同步区块信息。在其他主机上安装以太坊客户端Geth，通过Geth命令进入该私有区块链，注意要指定相同的网络号。</p>
<p>假设有两个节点：节点一和节点二，NetWorkID 都是 6666，通过下面的步骤就可以从节点一连接到节点二。</p>
<p>首先要知道节点二的 enode 信息，在节点二的 Geth Console 中执行下面的命令查看 enode 信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; admin.nodeInfo.enode</span><br><span class="line"><span class="string">"enode://d465bcbd5c34da7f4b8e00cbf9dd18e7e2c38fbd6642b7435f340c7d5168947ff2b822146e1dc1b07e02f7c15d5ca09249a92f1d0caa34587c9b2743172259ee@[::]:30303"</span></span><br></pre></td></tr></table></figure>
<p>然后在节点一的 Geth Console 中执行 <code>admin.addPeer()</code>，就可以连接到节点二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; admin.addPeer(<span class="string">"enode://d465bcbd5c34da7f4b8e00cbf9dd18e7e2c38fbd6642b7435f340c7d5168947ff2b822146e1dc1b07e02f7c15d5ca09249a92f1d0caa34587c9b2743172259ee@[::]:30303"</span>)</span><br></pre></td></tr></table></figure>
<p><code>addPeer()</code> 的参数就是节点二的 enode 信息，注意要把 enode 中的 <code>[::]</code> 替换成节点二的 IP 地址。连接成功后，节点二就会开始同步节点一的区块，同步完成后，任意一个节点开始挖矿，另一个节点会自动同步区块，向任意一个节点发送交易，另一个节点也会收到该笔交易。</p>
<p>通过 <code>admin.peers</code>可以查看连接到的其他节点信息，通过 <code>net.peerCount</code>可以查看已连接到的节点数量。</p>
<p>除了上面的方法，也可以在启动节点的时候指定<code>--bootnodes</code>选项连接到其他节点。</p>
<blockquote>
<p>如果只是自己测试开发使用，建议使用dev环境，在需要在启动时增加<code>–dev</code>参数即可，在dev模式下会监听交易，一旦有交易发送就会打包然后挖矿确认，且默认的<code>account[0]</code>开发者账户初始有一大堆以太币。</p>
</blockquote>
<h2 id="3、智能合约操作"><a href="#3、智能合约操作" class="headerlink" title="3、智能合约操作"></a>3、智能合约操作</h2><h3 id="3-1、创建和编译智能合约"><a href="#3-1、创建和编译智能合约" class="headerlink" title="3.1、创建和编译智能合约"></a>3.1、创建和编译智能合约</h3><p>经过part2的学习大家已经基本上掌握了Solidity，接下来我们编写一个智能合约：</p>
<p>该合约包含一个方法 multiply()，将输入的两个数相乘后输出：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line">contract TestContract</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">uint a, uint b</span>) <span class="title">returns</span> (<span class="params">uint</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将上面的代码复制到Remix编辑器里，程序将自动完成编译。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-8.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 8</div>
</center>


<p>点击 run 在Environment中设选择JavaScript VM, Value可设置为1，点击Deploy，则可创建该部署智能合约的交易。</p>
<p>因为我们要将该智能合约部署到私有链上，需要得到智能合约编译后的EVM二进制码和JSON ABI（Application Binary Interface）。将生成的交易保存到scenario.json文件，点击箭头所指按钮</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-9.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 9</div>
</center>



<p>其中38-65行为该智能合约的ABI（注意前面还有一个[符号），ABI指定了合约接口，包括可调用的合约方法、变量、事件等。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-10.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 10</div>
</center>


<p>input`字段为合约EVM二进制码，可点击直接复制。</p>
<p>在Linux下可以直接使用安装好的编译器进行编译，把合约代码保存到文件名为testContract.sol 里,通过下面两个命令分别得到EVM二进制码和JSON ABI。</p>
<p>如果没有安装solc先执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo snap install solc</span><br></pre></td></tr></table></figure>
<p>接下来执行<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$solc --bin testContract.sol</span><br><span class="line">$solc --abi testContract.sol</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-11.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 11</div>
</center>


<h3 id="3-2、部署智能合约"><a href="#3-2、部署智能合约" class="headerlink" title="3.2、部署智能合约"></a>3.2、部署智能合约</h3><p>回到 Geth 的控制台，用变量 code 和 abi 记录上面两个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; code = <span class="string">"608060405234801561001057600080fd5b5060b88061001f6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063165c4a1614602d575b600080fd5b606060048036036040811015604157600080fd5b8101908080359060200190929190803590602001909291905050506076565b6040518082815260200191505060405180910390f35b600081830290509291505056fea265627a7a7231582049ecffb2740a6e31f7c8fbf4a928b88d3a95f417b985dc23cd1ad4c06a9b043864736f6c63430005100032"</span></span><br><span class="line">&gt; abi = [&#123;</span><br><span class="line">    <span class="string">"0xd1ef8ab8f12bde83ebaee1be4183c75f45ab5835643812016a7751173bfb9dc0"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"a"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"b"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"multiply"</span>,</span><br><span class="line">        <span class="string">"outputs"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br></pre></td></tr></table></figure>
<p>使用账户 0 来部署合约，首先解锁账户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[<span class="number">0</span>])</span><br><span class="line">Unlock account <span class="number">0xb51654f60dee35265558a1d2e61468fe00f12888</span></span><br><span class="line">Passphrase:</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>创建合约实例，发送部署合约的交易：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; myContract = eth.contract(abi)   </span><br><span class="line">...</span><br><span class="line">&gt; contract = myContract.new(&#123;<span class="attr">from</span>:eth.accounts[<span class="number">0</span>],<span class="attr">data</span>:code,<span class="attr">gas</span>:<span class="number">1000000</span>&#125;)</span><br></pre></td></tr></table></figure>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-12.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 12</div>
</center>

<p>此时如果没有挖矿，用 <code>txpool.status</code> 命令可以看到本地交易池中有一个待确认的交易。使用 <code>miner.start()</code> 命令开始挖矿，一段时间后交易会被确认。通过查询该交易可得到合约地址，使用命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;eth.getTransactionReceipt(<span class="string">"0x085b66b2591ee31c3ad58a66ca485bd19bea6c1fc8ca7550a896853ab52855a6"</span>)</span><br><span class="line">contractAddress: <span class="string">"0xd92845cc4bffc1d6a4b6a389933b88880d5ded24"</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3、调用智能合约"><a href="#3-3、调用智能合约" class="headerlink" title="3.3、调用智能合约"></a>3.3、调用智能合约</h3><p>使用以下命令通过发送交易来调用合约，sendTransaction 方法的前几个参数应该与合约中 multiply 方法的输入参数对应。这种情况下，交易会通过挖矿记录到区块链中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;contract.multiply.sendTransaction(<span class="number">2</span>, <span class="number">4</span>, &#123;<span class="attr">from</span>:eth.accounts[<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>在本地运行该方法可直接查看返回结果，不会记录到区块链中，命令如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;contract.multiply.call(<span class="number">2</span>，<span class="number">4</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>如果其他节点要调用这个已经部署好的合约，需要知道该合约的地址以及ABI。可以通过发送交易调用，也可以本地调用。我们以本地调用为例。<br>创建合约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;abi = [&#123;</span><br><span class="line">    <span class="string">"0xd1ef8ab8f12bde83ebaee1be4183c75f45ab5835643812016a7751173bfb9dc0"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"a"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"b"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"multiply"</span>,</span><br><span class="line">        <span class="string">"outputs"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"function"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&gt;sample=eth.contract(abi)</span><br><span class="line">&gt;samplecontract=sample.at(<span class="string">"0xd92845cc4bffc1d6a4b6a389933b88880d5ded24"</span>)</span><br></pre></td></tr></table></figure>
<p>调用合约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;samplecontract.multiply.call(<span class="number">2</span>，<span class="number">4</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h2 id="4、web3-js-简介"><a href="#4、web3-js-简介" class="headerlink" title="4、web3.js 简介"></a>4、web3.js 简介</h2><p>我们除了通过Geth的JavaScript Console进行交互以外，还有许多第三方库可以使用，方便开发基于以太坊区块链的应用：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part3-13.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 13</div>
</center>


<p>本文使用web3.js与Geth客户端交互，首先搭建开发环境。</p>
<h3 id="4-1-环境搭建"><a href="#4-1-环境搭建" class="headerlink" title="4.1 环境搭建"></a>4.1 环境搭建</h3><p><strong>4.1.1 node.js安装</strong></p>
<p>更新源<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install -y python-software-properties software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:chris-lea/node.js</span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br></pre></td></tr></table></figure></p>
<p>node.js、npm安装<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install nodejs</span><br><span class="line">sudo apt install nodejs-legacy</span><br><span class="line">sudo apt install npm</span><br></pre></td></tr></table></figure><br>安装完后，可以通过 <code>node --version npm --version</code> 查看是否安装成功及版本号。npm 包管理工具随 node 一起安装，如果版本太低，建议升到新版本。</p>
<p><strong>4.1.2 web3.js模块安装</strong><br>使用npm可完成本地安装、全局安装模块。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -global &lt;package name&gt; <span class="comment">//全局安装</span></span><br><span class="line">npm install &lt;package name&gt; <span class="comment">//本地安装</span></span><br></pre></td></tr></table></figure></p>
<p>我这里选择使用本地安装模块，这样方便开发的应用移植、上线等。创建一个工程文件夹etherjs。在该文件夹下初始化一个新的 package.json 文件，使用下面命令自动生成。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></p>
<p>本地安装并添加模块名到 package.json<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install &lt;package name&gt; --save</span><br><span class="line">或者npm install &lt;package name&gt; --save-dev</span><br></pre></td></tr></table></figure></p>
<p>区别在于—save-dev 是你开发时候依赖的东西，—save 是你发布之后还依赖的东西。一般使用—save。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install web3 --save</span><br></pre></td></tr></table></figure></p>
<p>如果这样安装不成功，使用下面命令安装指定版本：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install web3@^<span class="number">0.20</span><span class="number">.1</span> --save</span><br></pre></td></tr></table></figure></p>
<p><strong>4.1.3 solc.js模块安装</strong><br>solc是用来编译智能合约的模块<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install solc --save</span><br></pre></td></tr></table></figure></p>
<p><strong>4.1.4 编译器——Visual Studio Code</strong></p>
<p>这里选择Visual Studio Code，适合node.js开发，集成的终端可以很方便运行程序。</p>
<p>安装Ubuntu Make<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make</span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install ubuntu-make</span><br></pre></td></tr></table></figure><br>安装visual-studio-code<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">umake web visual-studio-code</span><br></pre></td></tr></table></figure><br>安装完成后，直接搜索Visual Studio Code应用，把图标拖拽到Unity启动器上，就可以方便使用了。</p>
<h3 id="4-2-web3-js-介绍"><a href="#4-2-web3-js-介绍" class="headerlink" title="4.2 web3.js 介绍"></a>4.2 web3.js 介绍</h3><p>web3js 的全称是Web3 JavaScript app API，它是一个JavaScript API库。要使DApper在以太坊上运行，我们可以使用web3.js库提供的web3对象。web3.js通过RPC调用与本地节点通信，它可以用于任何暴露了RPC层的以太坊节点，web3包含了eth对象 - web3.eth（专门与以太坊区块链交互）和 shh对象 - web3.shh（用于与 Whisper交互）[Whisper是以太坊生态系统的一部分，主要用来做消息传递]</p>
<p>如果我们想要在以太坊上开发合约，目前来说最方便的方法就是调用Web3.js库，它会给我们一个Web3对象。我们进入geth控制台，直接键入web3就可以看到所有的方法。下面主要介绍如何通过web3js创建合约并调用</p>
<p><strong>4.2.1异步回调（callback）</strong></p>
<ul>
<li>web3js API 设计的最初目的，主要是为了和本地 RPC 节点共同使用，所以默认情况下发送的是同步 HTTP 请求</li>
<li>如果要发送异步请求，可以在函数的最后一个参数位置上，传入一个回调函数。回调函数是可选（optioanl）的</li>
<li><p>我们一般采用的回调风格是所谓的“错误优先”，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.getBlock(<span class="number">48</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!error)</span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　　<span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>4.2.2 回调 Promise 事件（v1.0.0）</strong></p>
<ul>
<li>为了帮助 web3 集成到不同标准的所有类型项目中，1.0.0 版本提供了多种方式来处理异步函数。大多数的 web3 对象允许将一个回调函数作为最后一个函数参数传入，同时会返回一个promise 用于链式函数调用。</li>
<li>以太坊作为一个区块链系统，一次请求具有不同的结束阶段。为了满足这样的要求，1.0.0 版本将这类函数调用的返回值包成一个“承诺事件”（promiEvent），这是一个 promise 和EventEmitter 的结合体。</li>
<li>PromiEvent 的用法就像 promise 一样，另外还加入了.on，.once 和.off方法</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;<span class="attr">from</span>: <span class="string">'0x123...'</span>, <span class="attr">data</span>: <span class="string">'0x432...'</span>&#125;)</span><br><span class="line">.once(<span class="string">'transactionHash'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">hash</span>)</span>&#123; ... &#125;)</span><br><span class="line">.once(<span class="string">'receipt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">receipt</span>)</span>&#123; ... &#125;)</span><br><span class="line">.on(<span class="string">'confirmation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">confNumber, receipt</span>)</span>&#123; ... &#125;)</span><br><span class="line">.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123; ... &#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">receipt</span>)</span>&#123; <span class="comment">// will be fired once the receipt is mined &#125;);</span></span><br></pre></td></tr></table></figure>
<p><strong>4.2.3 应用二进制接口（ABI）</strong></p>
<ul>
<li>web3.js 通过以太坊智能合约的 json 接口（Application Binary Interface，ABI）创建一个 JavaScript 对象，用来在 js代码中描述\</li>
<li>函数（functions）</li>
<li>type：函数类型，默认“function”，也可能是“constructor”</li>
<li>constant, payable, stateMutability：函数的状态可变性</li>
<li>inputs, outputs: 函数输入、输出参数描述列表</li>
<li>事件（events）</li>
<li>type：类型，总是“event”</li>
<li>inputs：输入对象列表，包括 name、type、indexed</li>
</ul>
<p><strong>4.2.4 批处理请求（batch requests）</strong></p>
<ul>
<li>批处理请求允许我们将请求排序，然后一起处理它们。</li>
<li>注意：批量请求不会更快。实际上，在某些情况下，一次性地发出许多请求会更快，因为请求是异步处理的。</li>
<li>批处理请求主要用于确保请求的顺序，并串行处理。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> batch = web3.createBatch();</span><br><span class="line">batch.add(web3.eth.getBalance.request(<span class="string">'0x0000000000000000</span></span><br><span class="line"><span class="string">000000000000000000000000'</span>, <span class="string">'latest'</span>, callback));</span><br><span class="line">batch.add(web3.eth.contract(abi).at(address).balance.request(a</span><br><span class="line">ddress, callback2));</span><br><span class="line">batch.execute();</span><br></pre></td></tr></table></figure>
<p><strong>4.2.5 大数处理（big numbers）</strong></p>
<ul>
<li>JavaScript 中默认的数字精度较小，所以web3.js 会自动添加一个依赖库 BigNumber，专门用于大数处理</li>
<li><p>对于数值，我们应该习惯把它转换成 BigNumber 对象来处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = <span class="keyword">new</span></span><br><span class="line">BigNumber(<span class="string">'131242344353464564564574574567456'</span>);</span><br><span class="line"><span class="comment">// or var balance = web3.eth.getBalance(someAddress);</span></span><br><span class="line">balance.plus(<span class="number">21</span>).toString(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//"131242344353464564564574574567477"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BigNumber.toString(10) 对小数只保留20位浮点精度。所以推荐的做法是，我们内部总是用 wei 来表示余额（大整数），只有在需要显示给用户看的时候才转换为ether或其它单位</p>
</li>
</ul>
<h3 id="4-3-常用-API-——-基本信息查询"><a href="#4-3-常用-API-——-基本信息查询" class="headerlink" title="4.3 常用 API —— 基本信息查询"></a>4.3 常用 API —— 基本信息查询</h3><p><strong>4.3.1 查看 web3 版本</strong></p>
<ul>
<li>v0.2x.x：web3.version.api</li>
<li>v1.0.0：web3.version</li>
</ul>
<p>查看 web3 连接到的节点版本（ clientVersion ）</p>
<ul>
<li>同步：web3.version.node</li>
<li>异步：web3.version.getNode((error,result)=&gt;{console.log(result)})</li>
<li>v1.0.0：web3.eth.getNodeInfo().then(console.log)</li>
</ul>
<p><strong>4.3.2 基本信息查询</strong></p>
<p>获取 network id</p>
<ul>
<li>同步：web3.version.network</li>
<li>异步：web3.version.getNetwork((err, res)=&gt;{console.log(res)})</li>
<li>v1.0.0：web3.eth.net.getId().then(console.log)</li>
</ul>
<p>获取节点的以太坊协议版本</p>
<ul>
<li>同步：web3.version.ethereum</li>
<li>异步：web3.version.getEthereum((err, res)=&gt;{console.log(res)}</li>
<li>v1.0.0：web3.eth.getProtocolVersion().then(console.log)</li>
</ul>
<p><strong>4.3.3 网络状态查询</strong></p>
<p>是否有节点连接 / 监听，返回 true/false</p>
<ul>
<li>同步：web3.isConnect() 或者 web3.net.listening</li>
<li>异步：web3.net.getListening((err,res)=&gt;console.log(res))</li>
<li>v1.0.0：web3.eth.net.isListening().then(console.log)</li>
</ul>
<p>查看当前连接的 peer 节点</p>
<ul>
<li>同步：web3.net.peerCount</li>
<li>异步：web3.net.getPeerCount((err,res)=&gt;console.log(res))</li>
<li>v1.0.0：web3.eth.net.getPeerCount().then(console.log)</li>
</ul>
<p><strong>4.3.4 Provider</strong></p>
<p>查看当前设置的 web3 provider</p>
<ul>
<li>web3.currentProvider</li>
</ul>
<p>查看浏览器环境设置的 web3 provider （ v1.0.0 ）</p>
<ul>
<li>web3.givenProvider</li>
</ul>
<p>设置 provider</p>
<ul>
<li>web3.setProvider(provider)</li>
<li>web3.setProvider(new web3.providers.HttpProvider(‘<a href="http://localhost:8545" target="_blank" rel="noopener">http://localhost:8545</a>‘))</li>
</ul>
<h3 id="4-4-web3-通用工具方法"><a href="#4-4-web3-通用工具方法" class="headerlink" title="4.4 web3 通用工具方法"></a>4.4 web3 通用工具方法</h3><p>以太单位转换</p>
<ul>
<li>web3.fromWei web3.toWei数据类型转换</li>
<li>web3.toString web3.toDecimal web3.toBigNumber字符编码转换</li>
<li>web3.toHex web3.toAscii web3.toUtf8 web3.fromUtf8地址相关</li>
<li>web3.isAddress web3.toChecksumAddress</li>
</ul>
<h3 id="4-5-web3-eth"><a href="#4-5-web3-eth" class="headerlink" title="4.5 web3.eth"></a>4.5 web3.eth</h3><p><strong>4.5.1 账户相关</strong></p>
<p>coinbase 查询</p>
<ul>
<li>同步：web3.eth.coinbase</li>
<li>异步：web3.eth.getCoinbase( (err, res)=&gt;console.log(res) )</li>
<li>v1.0.0：web3.eth.getCoinbase().then(console.log)</li>
</ul>
<p>账户查询</p>
<ul>
<li>同步：web3.eth.accounts</li>
<li>异步：web3.eth.getAccounts( (err, res)=&gt;console.log(res) )</li>
<li>v1.0.0：web3.eth.getAccounts().then(console.log)</li>
</ul>
<p><strong>4.5.2 区块相关</strong></p>
<p>区块高度查询</p>
<ul>
<li>同步：web3.eth. blockNumber</li>
<li>异步：web3.eth.getBlockNumber( callback )</li>
</ul>
<p>gasPrice 查询</p>
<ul>
<li>同步：web3.eth.gasPrice</li>
<li>异步：web3.eth.getGasPrice( callback )</li>
</ul>
<p>区块查询</p>
<ul>
<li>同步：web3.eth.getBlockNumber( hashStringOrBlockNumber[ ,returnTransactionObjects] )</li>
<li>异步：web3.eth.getBlockNumber( hashStringOrBlockNumber, callback )</li>
</ul>
<p>块中交易数量查询</p>
<ul>
<li>同步：web3.eth.getBlockTransactionCount( hashStringOrBlockNumber )</li>
<li>异步：web3.eth.getBlockTransactionCount( hashStringOrBlockNumber, callback )</li>
</ul>
<p><strong>4.5.3 交易相关</strong></p>
<p>余额查询</p>
<ul>
<li>同步：web3.eth.getBalance(addressHexString [, defaultBlock])</li>
<li>异步：web3.eth.getBalance(addressHexString [, defaultBlock][, callback])</li>
</ul>
<p>交易查询</p>
<ul>
<li>同步：web3.eth.getTransaction(transactionHash)</li>
<li>异步：web3.eth.getTransaction(transactionHash [, callback])</li>
</ul>
<p>交易执行相关</p>
<ul>
<li>交易收据查询（已进块）</li>
<li>同步：web3.eth.getTransactionReceipt(hashString)</li>
<li>异步：web3.eth.getTransactionReceipt(hashString [,callback])</li>
<li>估计 gas 消耗量</li>
<li>同步：web3.eth.estimateGas(callObject)</li>
<li>异步：web3.eth.estimateGas(callObject [, callback])</li>
</ul>
<p><strong>4.5.4 发送交易</strong></p>
<ul>
<li>web3.eth.sendTransaction(transactionObject [, callback])</li>
<li>交易对象：</li>
<li>from：发送地址</li>
<li>to：接收地址，如果是创建合约交易，可不填</li>
<li>value：交易金额，以wei为单位，可选</li>
<li>gas：交易消耗 gas 上限，可选</li>
<li>gasPrice：交易 gas 单价，可选</li>
<li>data：交易携带的字串数据，可选</li>
<li>nonce：整数 nonce 值，可选</li>
</ul>
<p><strong>4.5.5 消息调用</strong></p>
<ul>
<li>web3.eth.call(callObject [, defaultBlock] [, callback])</li>
<li>参数：<ul>
<li>调用对象：与交易对象相同，只是from也是可选的</li>
<li>默认区块：默认“latest”，可以传入指定的区块高度</li>
<li>回调函数，如果没有则为同步调用</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = web3.eth.call(&#123; <span class="attr">to</span>:<span class="string">"0xc4abd0339eb8d57087278718986382264244252f"</span>,</span><br><span class="line">data:<span class="string">"0xc6888fa1000000000000000000000000000000000000000000000000000 0000000000003"</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p><strong>4.5.6 日志过滤（事件监听）</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.filter( filterOptions [ , callback ] )</span><br><span class="line"><span class="comment">// filterString 可以是 'latest' or 'pending'</span></span><br><span class="line"><span class="keyword">var</span> filter = web3.eth.filter(filterString);</span><br><span class="line"><span class="comment">// 或者可以填入一个日志过滤 options</span></span><br><span class="line"><span class="keyword">var</span> filter = web3.eth.filter(options);</span><br><span class="line"><span class="comment">// 监听日志变化</span></span><br><span class="line">filter.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123; <span class="keyword">if</span> (!error) <span class="built_in">console</span>.log(result); &#125;);</span><br><span class="line"><span class="comment">// 还可以用传入回调函数的方法，立刻开始监听日志</span></span><br><span class="line">web3.eth.filter(options, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!error) <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>4.5.7 合约相关 —— 创建合约</strong></p>
<p>web3.eth.contract</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyContract = web3.eth.contract(abiArray);</span><br><span class="line"><span class="comment">// 通过地址初始化合约实例</span></span><br><span class="line"><span class="keyword">var</span> contractInstance = MyContract.at(address);</span><br><span class="line"><span class="comment">// 或者部署一个新合约</span></span><br><span class="line"><span class="keyword">var</span> contractInstance = MyContract.new([constructorParam1][, constructorParam2], &#123;<span class="attr">data</span>: <span class="string">'0x12345...'</span>, <span class="attr">from</span>:myAccount, <span class="attr">gas</span>: <span class="number">1000000</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>4.5.8 调用合约函数</strong></p>
<p>可以通过已创建的合约实例，直接调用合约函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接调用，自动按函数类型决定用 sendTransaction 还是 call</span></span><br><span class="line">myContractInstance.myMethod(param1 [, param2, ...] [,transactionObject] [, defaultBlock] [, callback]);</span><br><span class="line"><span class="comment">// 显式以消息调用形式 call 该函数</span></span><br><span class="line">myContractInstance.myMethod.call(param1 [, param2, ...] [,transactionObject] [, defaultBlock] [, callback]);</span><br><span class="line"><span class="comment">// 显式以发送交易形式调用该函数</span></span><br><span class="line">myContractInstance.myMethod.sendTransaction(param1 [,param2, ...] [, transactionObject] [, callback]);</span><br></pre></td></tr></table></figure>
<p><strong>4.5.9 监听合约事件</strong></p>
<p>合约的 event 类似于 filter，可以设置过滤选项来监听</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = myContractInstance.MyEvent(&#123;<span class="attr">valueA</span>: <span class="number">23</span>&#125;[, additionalFilterObject])</span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">event.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123; </span><br><span class="line"><span class="keyword">if</span> (!error) </span><br><span class="line">　　<span class="built_in">console</span>.log(result); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 还可以用传入回调函数的方法，立刻开始监听事件</span></span><br><span class="line"><span class="keyword">var</span> event = myContractInstance.MyEvent([&#123;<span class="attr">valueA</span>: <span class="number">23</span>&#125;][, additionalFilterObject] , <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (!error) <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="5、交互实现——部署智能合约"><a href="#5、交互实现——部署智能合约" class="headerlink" title="5、交互实现——部署智能合约"></a>5、交互实现——部署智能合约</h2><p>通过编写一个depoly.js程序实现自动化的部署智能合约。首先要保持Geth客户端正常运行，并开启rpc。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">geth --identity <span class="string">"TestNode"</span> --rpc --rpcport <span class="string">"8545"</span> --datadir data0 --port <span class="string">"30303"</span> --nodiscover --networkid <span class="number">6666</span> --rpcapi admin,eth,miner,personal,txpool,eth,web3,net <span class="built_in">console</span></span><br></pre></td></tr></table></figure>
<p>合约应该在智能合约编译器（如remix）调试好，然后将其写到test.sol文件里。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line">contract TestContract</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">uint a, uint b</span>) <span class="title">returns</span> (<span class="params">uint</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用solc模块生成合约的code和abi，我将该过程自定义为一个模块test.js，方便depoly.js调用。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> solc = <span class="built_in">require</span>(<span class="string">'solc'</span>);</span><br><span class="line"><span class="comment">//compile smart contract to get bytecode and abi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = fs.readFileSync(<span class="string">"./test.sol"</span>,<span class="string">'utf8'</span>);  <span class="comment">//读取代码</span></span><br><span class="line">    <span class="comment">//console.log("compiling contract...");</span></span><br><span class="line"><span class="keyword">var</span> compiledcontract = solc.compile(source); <span class="comment">//编译</span></span><br><span class="line">    <span class="comment">//console.log('done');</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> contractName <span class="keyword">in</span> compiledcontract.contracts)&#123;</span><br><span class="line">    <span class="keyword">var</span> bytecode = compiledcontract.contracts[contractName].bytecode;</span><br><span class="line">    <span class="keyword">var</span> abi = <span class="built_in">JSON</span>.parse(compiledcontract.contracts[contractName].interface);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(JSON.stringify(abi, undefined, 2));</span></span><br><span class="line"><span class="comment">//console.log(bytecode);</span></span><br><span class="line"><span class="comment">//console.log(abi);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bytecode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bytecode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(abi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">bytecode</span>:bytecode,<span class="attr">abi</span>:abi&#125;;</span><br></pre></td></tr></table></figure><br>depoly.js通过与Geth交互部署智能合约。当合约被区块链确认后，会直接返回合约地址。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="keyword">var</span> contract = <span class="built_in">require</span>(<span class="string">'./test'</span>);</span><br><span class="line"><span class="keyword">var</span> web;</span><br><span class="line"></span><br><span class="line"><span class="comment">//connect to node</span></span><br><span class="line"><span class="keyword">var</span> ethereumUri = <span class="string">'http://localhost:8545'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(ethereumUri));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询区块链中基本的账户信息</span></span><br><span class="line"><span class="keyword">if</span>(!web3.isConnected())&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to connect to ethereum node at '</span>+ ethereumUri);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'connected to etherum node at '</span>+ ethereumUri);</span><br><span class="line">    <span class="keyword">var</span> coinbase = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'coinbase:'</span> + coinbase);</span><br><span class="line">    <span class="keyword">var</span> balance = web3.eth.getBalance(coinbase);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'balance:'</span> + web3.fromWei(balance, <span class="string">'ether'</span>) + <span class="string">" ETH"</span>);</span><br><span class="line">    <span class="keyword">var</span> accounts = web3.eth.accounts;</span><br><span class="line">    <span class="built_in">console</span>.log(accounts);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过coinbase部署智能合约</span></span><br><span class="line"><span class="keyword">var</span> abi = contract.abi;</span><br><span class="line"><span class="keyword">var</span> bytecode = contract.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (web3.personal.unlockAccount(coinbase, <span class="string">'123'</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;coinbase&#125;</span> is unlocaked`</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`unlock failed, <span class="subst">$&#123;coinbase&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gasEstimate = web3.eth.estimateGas(&#123;<span class="attr">data</span>: <span class="string">'0x'</span> + bytecode&#125;); <span class="comment">//gas估计</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'gasEstimate = '</span> + gasEstimate);</span><br><span class="line"><span class="keyword">var</span> MyContract = web3.eth.contract(abi);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'deploying contract...'</span>);</span><br><span class="line"><span class="keyword">var</span> myContractReturned = MyContract.new(&#123;</span><br><span class="line">    <span class="keyword">from</span>: coinbase,</span><br><span class="line">    data: <span class="string">'0x'</span>+ bytecode,</span><br><span class="line">    gas: gasEstimate + <span class="number">50000</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, myContract</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!myContract.address) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`myContract.transactionHash = <span class="subst">$&#123;myContract.transactionHash&#125;</span>`</span>); <span class="comment">// The hash of the transaction, which deploys the contract</span></span><br><span class="line">        <span class="comment">// check address on the second call (contract deployed)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`myContract.address = <span class="subst">$&#123;myContract.address&#125;</span>`</span>); <span class="comment">// the contract address</span></span><br><span class="line">            global.contractAddress = myContract.address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>参考自：</strong></p>
<p><a href="https://geth.ethereum.org/docs/install-and-build/installing-geth" target="_blank" rel="noopener">Go Ethereum</a></p>
<p><a href="https://www.jianshu.com/p/9fa31e4cdf4d" target="_blank" rel="noopener">以太坊私有链Geth控制台操作教程</a></p>
<p><a href="https://www.bilibili.com/video/BV1sJ411D72u" target="_blank" rel="noopener">尚硅谷区块链全套Go语言→GoWeb→以太坊→项目实战</a><br><a href="http://cw.hubwiz.com/card/c/web3.js-1.0/" target="_blank" rel="noopener">web3.js 1.0中文手册</a></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>区块链入门（三）Solidity基础</title>
    <url>/posts/f6ff6959.html</url>
    <content><![CDATA[<font color="red"> 注：本教程为技术教程，不谈论且不涉及炒作任何数字货币 </font>

<h1 id="Solidity-入门教学"><a href="#Solidity-入门教学" class="headerlink" title="Solidity 入门教学"></a>Solidity 入门教学</h1><h2 id="1、-简介"><a href="#1、-简介" class="headerlink" title="1、 简介"></a>1、 简介</h2><h3 id="1-1-Solidity是什么"><a href="#1-1-Solidity是什么" class="headerlink" title="1.1 Solidity是什么"></a>1.1 Solidity是什么</h3><ul>
<li>Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在以太坊虚拟机（EVM）上运行。</li>
<li>Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。</li>
<li>内含的类型除了常见编程语言中的标准类型，还包括 <code>address</code>等以太坊独有的类型，Solidity 源码文件通常以 .sol 作为扩展名</li>
<li>目前尝试 Solidity 编程的推荐方式是使用 Remix。Remix是一个基于 Web 浏览器的 IDE，它可以让你编写 Solidity 智能合约，然后部署并运行该智能合约。</li>
</ul>
<h3 id="1-2-Solidity语言特性"><a href="#1-2-Solidity语言特性" class="headerlink" title="1.2 Solidity语言特性"></a>1.2 Solidity语言特性</h3><p>Solidity的语法接近于JavaScript，是一种面向对象的语言。但作为一种真正意义上运行在网络上的去中心合约，它又有很多的不同：</p>
<ul>
<li>以太坊底层基于帐户，而不是 <a href="https://cloud.tencent.com/developer/article/1367743" target="_blank" rel="noopener">UTXO</a>，所以增加了一个特殊的address 的数据类型用于定位用户和合约账户。</li>
<li>语言内嵌框架支持支付。提供了 <code>payable</code> 等关键字，可以在语言层面直接支持支付。</li>
<li>使用区块链进行数据存储。数据的每一个状态都可以永久存储，所以在使用时需要确定变量使用内存，还是区块链存储。</li>
<li>运行环境是在去中心化的网络上，所以需要强调合约或函数执行的调用的方式。</li>
<li>不同的异常机制。一旦出现异常，所有的执行都将会被回撤，这主要是为了保证合约执行的原子性，以避免中间状态出现的数据不一致。</li>
</ul>
<h3 id="1-3-Solidity源码和智能合约"><a href="#1-3-Solidity源码和智能合约" class="headerlink" title="1.3 Solidity源码和智能合约"></a>1.3 Solidity源码和智能合约</h3><p>Solidity 源代码要成为可以运行在以太坊上的智能合约需要经历如下的</p>
<p><strong>步骤：</strong></p>
<ol>
<li>用 Solidity 编写的智能合约源代码需要先使用编译器编译为字节码（Bytecode），编译过程中会同时产生智能合约的二进制接口规范（Application Binary Interface，简称为ABI）；</li>
<li>通过交易（Transaction）的方式将字节码部署到以太坊网络，每次成功部署都会产生一个新的智能合约账户；</li>
<li>使用 Javascript 编写的 DApp 通常通过 web3.js + ABI去调用智能合约中的函数来实现数据的读取和修改。</li>
</ol>
<h3 id="1-4-合约结构"><a href="#1-4-合约结构" class="headerlink" title="1.4 合约结构"></a>1.4 合约结构</h3><ul>
<li>状态变量（State Variables）作为合约状态的一部分，值会永久保存在存储空间内。</li>
<li>函数（Functions）合约中可执行的代码块。</li>
<li>函数修饰器（Function Modifiers）在函数声明中，用来补充修饰函数的语义。</li>
<li>事件（Events）非常方便的 EVM 日志工具接口。</li>
</ul>
<h2 id="2、-Solidity编译器安装以及简单使用"><a href="#2、-Solidity编译器安装以及简单使用" class="headerlink" title="2、 Solidity编译器安装以及简单使用"></a>2、 Solidity编译器安装以及简单使用</h2><p>Remix 是一个开源的 IDE,是一个浏览器在线编辑器。作为 Solidity 智能合约开发环境，Solidity IDE  Remix(在线浏览器编辑器)提供基本的编译、部署至本地或测试网络、执行合约等功能。</p>
<h3 id="2-1-remix安装以及使用"><a href="#2-1-remix安装以及使用" class="headerlink" title="2.1 remix安装以及使用"></a>2.1 remix安装以及使用</h3><ol>
<li><strong>浏览器端配置</strong></li>
</ol>
<p>在浏览器端有俩个选择，分别为英文版与中文版（有些许差别）</p>
<ul>
<li><p>Remix中文版地址：<a href="http://remix.hubwiz.com" target="_blank" rel="noopener">http://remix.hubwiz.com</a></p>
</li>
<li><p>Remix英文版地址（<strong>推荐</strong>）：<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">https://remix.ethereum.org/</a></p>
</li>
</ul>
<p><strong>PS.可能需要科学上网</strong></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-1.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 1</div>
</center>



<p>下面都以<code>英文版</code>为例子介绍</p>
<p>1、<strong>浏览器输入 <a href="https://remix.ethereum.org/" target="_blank" rel="noopener">https://remix.ethereum.org/</a></strong></p>
<p>如果出现加载慢，加载不完全的情况，刷新几次即可</p>
<p>2、左侧可以看到我们所有的文件，下面是我们的remix控制台</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-2.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 2</div>
</center>



<p>上图小图标从左到右依次为：</p>
<ul>
<li>创建新文件</li>
<li>创建新文件夹</li>
<li>Github代码片段分享</li>
<li>表示打开一个本地文件</li>
</ul>
<p>控制台图片如下：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-3.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 3</div>
</center>



<ul>
<li>1 从左至右表示隐藏控制台、清除控制台输出、pending的交易数量</li>
<li>2 表示监听所有交易</li>
<li>3 表示搜索框</li>
<li>4 表示输出区域</li>
<li>5 表示使用JavaScript与以太坊交互的区域，可以使用Web3对象</li>
</ul>
<p>3、点击文件样式图标输入我们的文件名即可(以.sol为后缀)</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-4.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 4</div>
</center>


<p>4、安装必要的插件</p>
<p>点击插件管理器，页面中为这个图标</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-5.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 5</div>
</center>




<ul>
<li><p>安装compiler</p>
<p>  搜索关键字compiler</p>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-6.png">
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">图 6</div>
</center>



</li>
</ul>
<p>5、写一个简单的样例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行就是告诉大家源代码使用Solidity版本0.4.0写的，并且使用0.4.0以上版本运行也没问题（最高到0.5.0，但是不包含0.5.0）。这是为了确保合约不会在新的编译器版本中突然行为异常。关键字 <code>pragma</code> 的含义是，一般来说，pragmas（编译指令）是告知编译器如何处理源代码的指令的。</p>
<p>Solidity中合约的含义就是一组代码（它的 函数 )和数据（它的 状态 ），它们位于以太坊区块链的一个特定地址上。 代码行 <code>uint storedData</code>; 声明一个类型为 <code>uint</code> (256位无符号整数）的状态变量，叫做 <code>storedData</code> 。 你可以认为它是数据库里的一个位置，可以通过调用管理数据库代码的函数进行查询和变更。对于以太坊来说，上述的合约就是拥有合约（owning contract）。在这种情况下，函数 <code>set</code> 和 <code>get</code> 可以用来变更或取出变量的值。</p>
<p>要访问一个状态变量，并不需要像 <code>this.</code> 这样的前缀，虽然这是其他语言常见的做法。</p>
<p>该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-7.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 7</div>
</center>



<p>点击<code>compile test.sol</code>，可以看到编译按钮，建议将<code>Auto compile</code>打钩（自动编译）,之后会在编译图标上看到一个以绿色为背景的对勾。</p>
<p>编译组件说明：</p>
<ul>
<li><code>Compiler</code>可以选择Solidity的编译器版本</li>
<li><code>Language</code>可以选择编程语言</li>
<li><code>EVM Version</code>可以选择EVM虚拟机版本</li>
<li><code>Auto compile</code>可以设置自动编译，修改完代码后自动执行编译操作</li>
<li><code>Enable optimization</code>可以设置对编译进行优化</li>
<li><code>Hide warnings</code>可以设置隐藏警告信息。</li>
<li><code>Contract</code>选择需要编译的合约</li>
<li><code>Publish on Swarm</code>和<code>Publish on Ipfs</code>分别将合约上传到Swarm和Ipfs这两个分布式文件系统上去</li>
<li><code>Compilation Details</code>很重要，可以查看编译的信息，包括ABI、字节码、函数Hash等</li>
<li><code>ABI</code>和<code>Bytecode</code>分别复制ABI和字节码。</li>
<li>再下面的部分空白用来显示编译的Warnings和Errors。</li>
</ul>
<p>我们点击<code>Compilation Details</code>就能看到编译之后的一些信息，如下图所示（部分）</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-8.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 8</div>
</center>


<ul>
<li><code>NAME</code>：合约名</li>
<li><code>METADATA</code>：一些编译相关的信息，比如版本、所用的语言、设置等</li>
<li><code>BYTECODE</code>：写入区块的字节码</li>
<li><code>ABI</code>：此智能合约对应的 ABI ，也就是我们合约里面定义的一些接口</li>
<li><code>WEB3DEPLOY</code>：智能合约编译之后的发布命令，这个就是比较重要的，之后的web3就是调用这段命令来部署合约的</li>
<li><code>METADATAHASH</code>：数据的一个哈希值</li>
<li><code>SWARMLOCATION</code>：Swarm网络的一个地址</li>
<li><code>FUNCTIONHASHES</code>：合约定义的方法的hash，其实我们执行合约的时候就是通过这个hash去找到对应的方法进行执行的</li>
<li><code>GASESTIMATES</code>：关于矿工费的一个预算，在ETH上进行合约的部署，执行等都是需要矿工费的。一般合约代码越多矿工费越高。</li>
</ul>
<p>点击下面的run图标，可以看到部署，以及账户信息，环境等等</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-9.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 9</div>
</center>



<p>点击deploy之后天可以看到自己的合约已经部署完成，打开之后可以看见我们写的函数<code>set</code>,<code>get</code>了，给<code>set</code>函数输入一个值，点击<code>get</code>会得到相应的值</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-10.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 10</div>
</center>



<ul>
<li><code>Environment</code> 表示合约部署的环境。<code>Javascript VM</code>是虚拟了一个节点，而<code>Injected Web3</code>和<code>Web3 Provider</code>则真正连接一个节点。</li>
<li><code>Account</code>代表不同的虚拟账户，每个虚拟账户每个有 100 ETH</li>
<li><code>Deploy</code>表示合约部署按钮</li>
<li><code>Deployed Contracts</code>表示已经部署的合约</li>
</ul>
<p>中文版界面与英文版界面有些许不一致，但都大同小异，想了解同学可以查看本博客(界面与中文版大致相同）：<br><a href="https://cloud.tencent.com/developer/article/1182404" target="_blank" rel="noopener">Solidity语言编辑器REMIX指导大全</a></p>
<ol>
<li><strong>本地配置：</strong><ul>
<li><a href="https://cloud.tencent.com/developer/article/1374376" target="_blank" rel="noopener">win下</a></li>
<li><a href="https://blog.csdn.net/qq_41944960/article/details/100134020" target="_blank" rel="noopener">ubuntu下</a></li>
</ul>
</li>
</ol>
<ol>
<li><strong>Docker</strong></li>
</ol>
<p>我们为编译器提供了最新的docker构建。 stable 仓库里的是已发布的版本，nightly 仓库则是在开发分支中的带有不稳定变更的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run ethereum&#x2F;solc:stable solc --version</span><br></pre></td></tr></table></figure>
<p>目前，docker 镜像只含有 solc 的可执行程序，因此你需要额外的工作去把源代码和输出目录连接起来。</p>
<h2 id="3、Solidity基础操作"><a href="#3、Solidity基础操作" class="headerlink" title="3、Solidity基础操作"></a>3、Solidity基础操作</h2><p><strong>由于篇幅有限，以下只会讲解一些较基础、重要的概念(足够后面使用)，有些可能会一带而过或者“忽略”，如果大家途中有没太明白地方建议先百度、Google，或者查看此教程<a href="https://solidity-cn.readthedocs.io/zh/develop/index.html" target="_blank" rel="noopener">Solifity中文文档</a>、<a href="https://remix-ide.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Solidity英文文档</a></strong></p>
<h3 id="3-1-Solidity源文件布局"><a href="#3-1-Solidity源文件布局" class="headerlink" title="3.1 Solidity源文件布局"></a>3.1 Solidity源文件布局</h3><p><strong>源文件可以被版本杂注pragma所注解，表明要求的编译器版本</strong></p>
<ul>
<li>例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br></pre></td></tr></table></figure>
这样，源文件将既不允许低于 0.4.0 版本的编译器编译， 也不允许高于（包含） 0.5.0 版本的编译器编译（第二个条件因使用 ^ 被添加）。 这种做法的考虑是，编译器在 0.5.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。</li>
</ul>
<p><strong>import（导入其它源文件）</strong></p>
<ul>
<li>Solidity 所支持的导入语句import，语法同 JavaScript（从ES6 起）非常类似</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"filename"</span>;</span><br></pre></td></tr></table></figure>
<p>从“filename”中导入所有的全局符号到当前全局作用域中<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> symbolName <span class="keyword">from</span> <span class="string">"filename"</span>;</span><br></pre></td></tr></table></figure><br>创建一个新的全局符号 symbolName，其成员均来自 “filename”中全局符号<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;symbol1 <span class="keyword">as</span> alias, symbol2&#125; <span class="keyword">from</span> <span class="string">"filename"</span>;</span><br></pre></td></tr></table></figure><br>创建新的全局符号 alias 和 symbol2，分别从 “filename” 引用 symbol1 和 symbol2<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"filename"</span> <span class="keyword">as</span> symbolName;</span><br></pre></td></tr></table></figure><br>这条语句等同于 import * as symbolName from “filename”;</p>
<p><strong>注释</strong></p>
<p>可以使用单行注释（//）和多行注释（/<em>…</em>/）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个</span></span><br><span class="line"><span class="comment">多行注释。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-数据类型与运算符"><a href="#3-2-数据类型与运算符" class="headerlink" title="3.2 数据类型与运算符"></a>3.2 数据类型与运算符</h3><h3 id="3-2-1-Solidity值类型介绍"><a href="#3-2-1-Solidity值类型介绍" class="headerlink" title="3.2.1 Solidity值类型介绍"></a>3.2.1 Solidity值类型介绍</h3><ul>
<li><strong>布尔（bool）</strong>：</li>
</ul>
<p>可能的取值为字符常量值 true 或 false</p>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract helloworld &#123;</span><br><span class="line">    bool boola=<span class="literal">true</span>; <span class="comment">//声明一个布尔类型的值，只用一个等号</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">booltesta</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boola;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">booltestb</span>(<span class="params">int a,int b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span>(<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-12.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 11</div>
</center>



<ul>
<li>整型（int/uint）**：</li>
</ul>
<p><code>int</code> / <code>uint</code> ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 <code>uint8</code> 到 <code>uint256</code> （无符号，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>，以 8 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p>
<ul>
<li><strong>定长浮点型（fixed / ufixed）</strong>： </li>
</ul>
<p><code>fixed</code>/ <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code>必须能整除 8，即 8 到 256 位。 <code>N</code>则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x19</code> 和 <code>fixed128x19</code> 的别名。</p>
<ul>
<li><strong>地址（address 重点，后面细讲）</strong>：</li>
</ul>
<p>地址类型存储一个 20 字节的值（以太坊地址的大小）。 地址类型也有成员变量，并作为所有合约的基础。</p>
<p> <strong>地址类型成员变量</strong>:<code>balance</code> 和 <code>transfer</code></p>
<p> 可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个地址发送 以太币 （以 wei 为单位）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">address x = <span class="number">0x123</span>;</span><br><span class="line">address myAddress = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>) x.transfer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>注：如果 <code>x</code> 是一个合约地址，它的代码（更具体来说是它的 fallback 函数，如果有的话）会跟 <code>transfer</code> 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币 交易会被打回，当前的合约也会在终止的同时抛出异常。</p>
<ul>
<li><strong>定长字节数组</strong>：</li>
</ul>
<p>关键字有 bytes1， bytes2， bytes3， …， bytes32<br><code>.length</code> 表示这个字节数组的长度（只读）.</p>
<p>注：可以将 <code>byte[]</code> 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 <code>bytes</code>。</p>
<ul>
<li><strong>变长字节数组</strong></li>
</ul>
<p><code>bytes</code>:变长字节数组。它并不是值类型。</p>
<p><code>string</code>:变长 UTF-8 编码字符串类型。并不是值类型。 </p>
<ul>
<li><strong>地址字面常数（Address Literals）</strong></li>
</ul>
<p>比如像 <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code> 这样的通过了地址校验和测试的十六进制字面常数属于 <code>address</code> 类型。 长度在 39 到 41 个数字的，没有通过校验和测试而产生了一个警告的十六进制字面常数视为正常的有理数字面常数。</p>
<ul>
<li><strong>有理数和整数字面常数</strong></li>
</ul>
<p>整数字面常数由范围在 0-9 的一串数字组成，表现成十进制。 例如，69 表示数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。</p>
<p>十进制小数字面常数带有一个 .，至少在其一边会有一个数字。 比如：<code>1.，.1</code>，和 <code>1.3</code>。</p>
<p>科学符号也是支持的，尽管指数必须是整数，但底数可以是小数。 比如：<code>2e10， -2e10， 2e-10， 2.5e1</code>。</p>
<p>数值字面常数表达式本身支持任意精度，除非它们被转换成了非字面常数类型（也就是说，当它们出现在非字面常数表达式中时就会发生转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。</p>
<p>例如， <code>(2**800 + 1) - 2**800</code> 的结果是字面常数 1 （属于 <code>uint8</code> 类型），尽管计算的中间结果已经超过了 以太坊虚拟机 的机器字长度。 此外， <code>.5 * 8</code> 的结果是整型 4 （尽管有非整型参与了计算）</p>
<ul>
<li><strong>字符串字面常数</strong></li>
</ul>
<p>字符串字面常数是指由双引号或单引号引起来的字符串（<code>&quot;foo&quot;</code>或者 <code>&#39;bar&#39;</code>）。 不像在 C 语言中那样带有结束符；<code>&quot;foo&quot;</code> 相当于 3 个字节而不是 4 个。 和整数字面常数一样，字符串字面常数的类型也可以发生改变，但它们可以隐式地转换成 <code>bytes1，……，bytes32</code>，如果合适的话，还可以转换成 <code>bytes</code> 以及 <code>string</code>。</p>
<ul>
<li><strong>十六进制字面常数</strong></li>
</ul>
<p>十六进制字面常数以关键字 <code>hex</code> 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，<code>hex&quot;001122FF&quot;</code>）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。</p>
<ul>
<li><strong>枚举（enum）</strong>：</li>
</ul>
<p>一种用户可以定义类型的方法，与C语言类似，默认从0开始递增，一般用来模拟合约的状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;；</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGoStraight</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span></span><br><span class="line">    <span class="comment">// "getChoice" 的签名会自动被改成 "getChoice() returns (uint8)"。</span></span><br><span class="line">    <span class="comment">// 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加，</span></span><br><span class="line">    <span class="comment">// 可以逐渐使用 `uint16` 或更大的整数类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">ActionChoices</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDefaultChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>函数（function）</strong>：</li>
</ul>
<p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类：- 内部（<code>internal</code>） 函数和 外部（<code>external</code>） 函数：</p>
<p>内部函数只能在当前合约内被调用（更具体来说，在当前代码块内，包括内部库函数和继承的函数中），因为它们不能在当前合约上下文的外部被执行。 调用一个内部函数是通过跳转到它的入口标签来实现的，就像在当前合约的内部调用一个函数。</p>
<p>外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。</p>
<p>函数类型表示成如下的形式</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="\Pic\Blockchain_Pic\part2-11.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图 12</div>
</center>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|constant|view|payable] [returns (<span class="xml"><span class="tag">&lt;<span class="name">return</span> <span class="attr">types</span>&gt;</span>)]</span></span><br></pre></td></tr></table></figure>
<p>与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 <code>returns (&lt;return types&gt;)</code> 部分。</p>
<p>函数类型默认是内部函数，因此不需要声明 <code>internal</code> 关键字。 与此相反的是，合约中的函数本身默认是 <code>public</code>的，只有当它被当做类型名称时，默认才是内部函数。</p>
<p>有两种方法可以访问当前合约中的函数：一种是直接使用它的名字，<code>f</code> ，另一种是使用 <code>this.f</code> 。 前者适用于内部函数，后者适用于外部函数。</p>
<p>如果当函数类型的变量还没有初始化时就调用它的话会引发一个异常。 如果在一个函数被 <code>delete</code> 之后调用它也会发生相同的情况。</p>
<p>如果外部函数类型在 Solidity 的上下文环境以外的地方使用，它们会被视为 <code>function</code> 类型。 该类型将函数地址紧跟其函数标识一起编码为一个 <code>bytes24</code> 类型。</p>
<p>请注意，当前合约的 public 函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 <code>f</code> 调用，如果想将其当作外部函数，使用 <code>this.f</code> 。</p>
<p><strong>Solidity函数可见性</strong></p>
<p>函数的可见性可以指定为 external，public ，internal 或者 private；对于状态变量，不能设置为 external ，默认是 internal。</p>
<ul>
<li>external ：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。</li>
<li>public ：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数。</li>
<li>internal ：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。</li>
<li>private ：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</li>
</ul>
<p><strong>Solidity函数状态可变性</strong></p>
<ul>
<li>pure：纯函数，不允许修改或访问状态</li>
<li>view：不允许修改状态</li>
<li>payable：允许从消息调用中接收以太币Ether 。</li>
<li>constant：与view相同，一般只修饰状态变量，不允许赋值（除初始化以外）</li>
</ul>
<p><strong>内部函数调用</strong></p>
<p>当前合约中的函数可以直接（“从内部”）调用，也可以递归调用，就像下边这个荒谬的例子一样<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123; <span class="keyword">return</span> f(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123; <span class="keyword">return</span> g(<span class="number">7</span>) + f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这些函数调用在 EVM 中被解释为简单的跳转。这样做的效果就是当前内存不会被清除，也就是说，通过内部调用在函数之间传递内存引用是非常有效的。</p>
<p><strong>外部函数调用</strong></p>
<p>表达式 <code>this.g(8)</code>; 和 <code>c.g(2)</code>; （其中 c 是合约实例）也是有效的函数调用，但是这种情况下，函数将会通过一个消息调用来被“外部调用”，而不是直接的跳转。 请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。</p>
<p>如果想要调用其他合约的函数，需要外部调用。对于一个外部调用，所有的函数参数都需要被复制到内存。</p>
<p>当调用其他合约的函数时，随函数调用发送的 Wei 和 gas 的数量可以分别由特定选项 <code>.value()</code> 和 <code>.gas()</code> 指定:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint ret</span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFeed</span>(<span class="params">address addr</span>) <span class="title">public</span> </span>&#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFeed</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123; feed.info.value(<span class="number">10</span>).gas(<span class="number">800</span>)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>payable</code> 修饰符要用于修饰 <code>info</code>，否则，.<code>value()</code> 选项将不可用。</p>
<p>注意，表达式 <code>InfoFeed(addr)</code> 进行了一个的显式类型转换，说明”我们知道给定地址的合约类型是 <code>InfoFeed</code> “并且这不会执行构造函数。 显式类型转换需要谨慎处理。绝对不要在一个你不清楚类型的合约上执行函数调用。</p>
<p>我们也可以直接使用 <code>function setFeed(InfoFeed _feed) { feed = _feed; }</code> 。 注意一个事实，<code>feed.info.value(10).gas(800)</code> 只（局部地）设置了与函数调用一起发送的 Wei 值和 gas 的数量，只有最后的圆括号执行了真正的调用。</p>
<p>如果被调函数所在合约不存在（也就是账户中不包含代码）或者被调用合约本身抛出异常或者 gas 用完等，函数调用会抛出异常。</p>
<h3 id="3-2-2-引用类型介绍"><a href="#3-2-2-引用类型介绍" class="headerlink" title="3.2.2 引用类型介绍"></a>3.2.2 引用类型介绍</h3><p>比起之前讨论过的值类型，在处理复杂的类型（即占用的空间超过 256 位的类型）时，我们需要更加谨慎。 由于拷贝这些类型变量的开销相当大，我们不得不考虑它的存储位置，是将它们保存在 <strong>内存</strong> （并不是永久存储）中， 还是 <strong>存储</strong> （保存状态变量的地方）中。</p>
<ul>
<li><strong>数据位置</strong></li>
</ul>
<p>所有的复杂类型，即 <strong>数组</strong> 和 <strong>结构</strong> 类型，都有一个额外属性，“数据位置”，说明数据是保存在 <strong>内存</strong> 中还是 <strong>存储</strong> 中。 根据上下文不同，大多数时候数据有默认的位置，但也可以通过在类型名后增加关键字 <code>storage</code> 或 <code>memory</code> 进行修改。 函数参数（包括返回的参数）的数据位置默认是 <code>memory</code>， 局部变量的数据位置默认是 <code>storage</code>，状态变量的数据位置强制是 <code>storage</code>。</p>
<p>也存在第三种数据位置， <code>calldata</code> ，这是一块只读的，且不会永久存储的位置，用来存储函数参数。 外部函数的参数（非返回参数）的数据位置被强制指定为 <code>calldata</code>，效果跟 <code>memory</code> 差不多。</p>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; <span class="comment">// x 的数据存储位置是 storage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memoryArray 的数据存储位置是 memory</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memoryArray</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        x = memoryArray; <span class="comment">// 将整个数组拷贝到 storage 中，可行</span></span><br><span class="line">        <span class="keyword">var</span> y = x;  <span class="comment">// 分配一个指针（其中 y 的数据存储位置是 storage），可行</span></span><br><span class="line">        y[<span class="number">7</span>]; <span class="comment">// 返回第 8 个元素，可行</span></span><br><span class="line">        y.length = <span class="number">2</span>; <span class="comment">// 通过 y 修改 x，可行</span></span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 清除数组，同时修改 y，可行</span></span><br><span class="line">        <span class="comment">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组， /</span></span><br><span class="line">        <span class="comment">// 但 storage 是“静态”分配的：</span></span><br><span class="line">        <span class="comment">// y = memoryArray;</span></span><br><span class="line">        <span class="comment">// 下面这一行也不可行，因为这会“重置”指针，</span></span><br><span class="line">        <span class="comment">// 但并没有可以让它指向的合适的存储位置。</span></span><br><span class="line">        <span class="comment">// delete y;</span></span><br><span class="line"></span><br><span class="line">        g(x); <span class="comment">// 调用 g 函数，同时移交对 x 的引用</span></span><br><span class="line">        h(x); <span class="comment">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[] storage storageArray</span>) <span class="title">internal</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">uint[] memoryArray</span>) <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>归纳：</p>
<p>强制指定的数据位置：</p>
<ol>
<li>外部函数的参数（不包括返回参数）： calldata</li>
<li>状态变量： storage</li>
</ol>
<p>默认数据位置：</p>
<ol>
<li>函数参数（包括返回参数）： memory</li>
<li>所有其它局部变量： storage</li>
</ol>
<ul>
<li><strong>数组</strong></li>
</ul>
<p>数组可以在声明时指定长度，也可以动态调整大小。 对于 <strong>存储</strong> 的数组来说，元素类型可以是任意的（即元素也可以是数组类型，映射类型或者结构体）。 对于 <strong>内存</strong> 的数组来说，元素类型不能是映射类型，如果作为 <code>public</code> 函数的参数，它只能是 <code>ABI</code> 类型。</p>
<p>一个元素类型为 <code>T</code>，固定长度为 <code>k</code> 的数组可以声明为 <code>T[k]</code>，而动态数组声明为 <code>T[]</code>。 </p>
<p>举个例子，一个长度为 5，元素类型为 <code>uint</code> 的动态数组的数组，应声明为 <code>uint[][5]</code> （注意这里跟其它语言比，数组长度的声明位置是反的）。 要访问第三个动态数组的第二个元素，你应该使用 <code>x[2][1]</code>（数组下标是从 0 开始的，且访问数组时的下标顺序与声明时相反，也就是说，<code>x[2]</code> 是从右边减少了一级）。。</p>
<p><code>bytes</code> 和 <code>string</code> 类型的变量是特殊的数组。 <code>bytes</code> 类似于 <code>byte[]</code>，但它在 <code>calldata</code> 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 <code>string</code> 与 <code>bytes</code> 相同，但（暂时）不允许用长度或索引来访问。</p>
<p>注：<br>如果想要访问以字节表示的字符串 s，请使用 <code>bytes(s)</code>.<code>length / bytes(s)[7] = &#39;x&#39;</code>;。 注意这时你访问的是 <code>UTF-8</code> 形式的低级<code>bytes</code> 类型，而不是单个的字符。</p>
<p><strong>成员</strong></p>
<p><code>length</code>:</p>
<p>数组有 length 成员变量表示当前数组的长度。 动态数组可以在 <strong>存储</strong> （而不是 <strong>内存</strong> ）中通过改变成员变量 .length 改变数组大小。 并不能通过访问超出当前数组长度的方式实现自动扩展数组的长度。 一经创建，<strong>内存</strong> 数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。<br><code>push</code>:<br>    变长的 <strong>存储</strong> 数组以及 bytes 类型（而不是 string 类型）都有一个叫做 push 的成员函数，它用来附加新的元素到数组末尾。 这个函数将返回新的数组长度。 </p>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[<span class="number">2</span>**<span class="number">20</span>] m_aLotOfIntegers;</span><br><span class="line">    <span class="comment">// 注意下面的代码并不是一对动态数组，</span></span><br><span class="line">    <span class="comment">// 而是一个数组元素为一对变量的动态数组（也就是数组元素为长度为 2 的定长数组的动态数组）。</span></span><br><span class="line">    bool[<span class="number">2</span>][] m_pairsOfFlags;</span><br><span class="line">    <span class="comment">// newPairs 存储在 memory 中 —— 函数参数默认的存储位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAllFlagPairs</span>(<span class="params">bool[<span class="number">2</span>][] newPairs</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向一个 storage 的数组赋值会替代整个数组</span></span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFlagPair</span>(<span class="params">uint index, bool flagA, bool flagB</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问一个不存在的数组下标会引发一个异常</span></span><br><span class="line">        m_pairsOfFlags[index][<span class="number">0</span>] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][<span class="number">1</span>] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeFlagArraySize</span>(<span class="params">uint newSize</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 newSize 更小，那么超出的元素会被清除</span></span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这些代码会将数组全部清空</span></span><br><span class="line">        <span class="keyword">delete</span> m_pairsOfFlags;</span><br><span class="line">        <span class="keyword">delete</span> m_aLotOfIntegers;</span><br><span class="line">        <span class="comment">// 这里也是实现同样的功能</span></span><br><span class="line">        m_pairsOfFlags.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">byteArrays</span>(<span class="params">bytes data</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字节的数组（语言意义中的 byte 的复数 ``bytes``）不一样，因为它们不是填充式存储的，</span></span><br><span class="line">        <span class="comment">// 但可以当作和 "uint8[]" 一样对待</span></span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += <span class="number">7</span>;</span><br><span class="line">        m_byteData[<span class="number">3</span>] = byte(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">delete</span> m_byteData[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addFlag</span>(<span class="params">bool[<span class="number">2</span>] flag</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createMemoryArray</span>(<span class="params">uint size</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 `new` 创建动态 memory 数组：</span></span><br><span class="line">        uint[<span class="number">2</span>][] memory arrayOfPairs = <span class="keyword">new</span> uint[<span class="number">2</span>][](size);</span><br><span class="line">        <span class="comment">// 创建一个动态字节数组：</span></span><br><span class="line">        bytes memory b = <span class="keyword">new</span> bytes(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>结构体</strong></li>
</ul>
<p>Solidity 支持通过构造结构体的形式定义新的类型，以下是一个结构体的示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Funder</span> &#123;</span></span><br><span class="line">    address addr;</span><br><span class="line">    uint amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Campaign</span> &#123;</span></span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint fundingGoal;</span><br><span class="line">    uint numFunders;</span><br><span class="line">    uint amount;</span><br><span class="line">    mapping (uint =&gt; Funder) funders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>映射</strong><br>映射类型在声明时的形式为 <code>mapping(_KeyType =&gt; _ValueType)</code>。 其中 <code>_KeyType</code> 可以是除了映射、变长数组、合约、枚举以及结构体以外的几乎所有类型。 <code>_ValueType</code> 可以是包括映射类型在内的任何类型。</li>
</ul>
<p>映射可以视作 哈希表 <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hash_table</a>，它们在实际的初始化过程中创建每个可能的 key， 并将其映射到字节形式全是零的值：一个类型的 默认值。然而下面是映射与哈希表不同的地方： 在映射中，实际上并不存储 key，而是存储它的 <code>keccak256</code> 哈希值，从而便于查询实际的值。</p>
<p>正因为如此，映射是没有长度的，也没有 <code>key</code> 的集合或 <code>value</code> 的集合的概念。</p>
<p>只有状态变量（或者在 internal 函数中的对于存储变量的引用）可以使用映射类型。。</p>
<p>可以将映射声明为 <code>public</code>，然后来让 Solidity 创建一个 getter。<code>_KeyType</code> 将成为 getter 的必须参数，并且 getter 会返回 <code>_ValueType</code>。</p>
<p><code>_ValueType</code> 也可以是一个映射。这时在使用 getter 时将将需要递归地传入每个 <code>_KeyType</code>参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-涉及-LValues-的运算符"><a href="#3-2-3-涉及-LValues-的运算符" class="headerlink" title="3.2.3 涉及 LValues 的运算符"></a>3.2.3 涉及 LValues 的运算符</h4><ul>
<li><strong>删除</strong></li>
</ul>
<p><code>delete a</code> 的结果是将 <code>a</code> 的类型在初始化时的值赋值给 <code>a</code>。即对于整型变量来说，相当于 <code>a = 0</code>， 但 delete 也适用于数组，对于动态数组来说，是将数组的长度设为 0，而对于静态数组来说，是将数组中的所有元素重置。 如果对象是结构体，则将结构体中的所有属性重置。</p>
<p>delete 对整个映射是无效的（因为映射的键可以是任意的，通常也是未知的）。 因此在你删除一个结构体时，结果将重置所有的非映射属性，这个过程是递归进行的，除非它们是映射。 然而，单个的键及其映射的值是可以被删除的。</p>
<p>理解 <code>delete a</code>的效果就像是给 <code>a</code> 赋值很重要，换句话说，这相当于在 <code>a</code>中存储了一个新的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 将 x 设为 0，并不影响数据</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 将 data 设为 0，并不影响 x，因为它仍然有个副本</span></span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        <span class="keyword">delete</span> dataArray;</span><br><span class="line">        <span class="comment">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，</span></span><br><span class="line">        <span class="comment">// 因为它是一个存储位置是 storage 的对象的别名。</span></span><br><span class="line">        <span class="comment">// 另一方面："delete y" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-单位和全局变量"><a href="#3-3-单位和全局变量" class="headerlink" title="3.3 单位和全局变量"></a>3.3 单位和全局变量</h3><h3 id="3-3-1-以太币单位"><a href="#3-3-1-以太币单位" class="headerlink" title="3.3.1 以太币单位"></a>3.3.1 以太币单位</h3><p>以太币 单位之间的换算就是在数字后边加上 <code>wei</code>、 <code>finney</code>、 <code>szabo</code> 或 <code>ether</code> 来实现的，如果后面没有单位，缺省为 <code>Wei</code>。例如 <code>2 ether == 2000 finney</code> 的逻辑判断值为 <code>true</code>。</p>
<h3 id="3-3-2-时间单位"><a href="#3-3-2-时间单位" class="headerlink" title="3.3.2 时间单位"></a>3.3.2 时间单位</h3><p>秒是缺省时间单位，在时间单位之间，数字后面带有 <code>seconds</code>、 <code>minutes</code>、 <code>hours</code>、 <code>days</code>、 <code>weeks</code> 和 <code>years</code> 的可以进行换算，基本换算关系与现实生活相符。</p>
<h3 id="3-3-3-特殊变量和函数"><a href="#3-3-3-特殊变量和函数" class="headerlink" title="3.3.3 特殊变量和函数"></a>3.3.3 特殊变量和函数</h3><p>在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。</p>
<p><strong>区块和交易属性</strong></p>
<ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 <code>blockhash(uint blockNumber)</code> 代替</li>
<li><code>block.coinbase (address)</code>: 挖出当前区块的矿工地</li>
<li><code>block.difficulty (uint)</code>: 当前区块难度</li>
<li><code>block.gaslimit (uint)</code>: 当前区块 <code>gas</code> 限额</li>
<li><code>block.number (uint</code>): 当前区块号</li>
<li><code>block.timestamp (uint)</code>: 自 <code>unix epoch</code> 起始当前区块以秒计的时间戳</li>
<li><code>gasleft() returns (uint256)</code>：剩余的 <code>gas</code></li>
<li><code>msg.data (bytes)</code>: 完整的 <code>calldata</code></li>
<li><code>msg.gas (uint)</code>: 剩余 <code>gas</code> - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替</li>
<li><strong><code>msg.sender (address)</code>:</strong> 消息发送者（当前调用）</li>
<li><code>msg.sig (bytes4)</code>: calldata 的前 4 字节（也就是函数标识符）</li>
<li><code>msg.value (uint)</code>: 随消息发送的 wei 的数量</li>
<li><code>now (uint)</code>: 目前区块时间戳（<code>block.timestamp</code>）</li>
<li><code>tx.gasprice (uint)</code>: 交易的<code>gas</code> 价格</li>
<li><code>tx.origin (address)</code>: 交易发起者（完全的调用链）</li>
</ul>
<p><strong><a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi" target="_blank" rel="noopener">ABI 编码函数</a></strong></p>
<ul>
<li><code>abi.encode(...) returns (bytes)</code>： ABI - 对给定参数进行编码</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 紧打包编码</li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)：</code> ABI - 对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
</ul>
<p><strong>错误处理</strong></p>
<ul>
<li><code>assert(bool condition)</code>:<br>  如果条件不满足，则使当前交易没有效果 — 用于检查内部错误。</li>
<li><code>require(bool condition)</code>:<br>  如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。</li>
<li><code>require(bool condition, string message)</code>:<br>  如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。</li>
<li><code>revert()</code>:<br>  终止运行并撤销状态更改。</li>
<li><code>revert(string reason)</code>:<br>  终止运行并撤销状态更改，可以同时提供一个解释性的字符串。</li>
</ul>
<p><strong>地址相关</strong></p>
<ul>
<li><code>&lt;address&gt;.balance (uint256)</code>:<br>  以 Wei 为单位的 地址类型 的余额。</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>:<br>  向 地址类型 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。</li>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>:<br>  向 地址类型 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。</li>
<li><code>&lt;address&gt;.call(...) returns (bool)</code>:<br>  发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。</li>
<li><code>&lt;address&gt;.callcode(...) returns (bool)</code>：<br>  发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。</li>
<li><code>&lt;address&gt;.delegatecall(...) returns (bool):</code><br>  发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 </li>
</ul>
<h3 id="3-4-表达式和控制结构"><a href="#3-4-表达式和控制结构" class="headerlink" title="3.4 表达式和控制结构(*)"></a>3.4 表达式和控制结构(*)</h3><h3 id="3-4-1-控制结构"><a href="#3-4-1-控制结构" class="headerlink" title="3.4.1 控制结构"></a>3.4.1 控制结构</h3><p>avaScript 中的大部分控制结构在 Solidity 中都是可用的，除了 <code>switch</code> 和 <code>goto</code>。 因此 Solidity 中有 <code>if，else，while，do，for，break，continue，return，? :</code>这些与在 C 或者 JavaScript 中表达相同语义的关键词。</p>
<p>用于表示条件的括号 <strong>不可以</strong> 被省略，单语句体两边的花括号可以被省略。</p>
<p>注意，与 C 和 JavaScript 不同， Solidity 中非布尔类型数值不能转换为布尔类型，因此 <code>if (1) { ... }</code> 的写法在 Solidity 中 无效 。</p>
<p>当一个函数有多个输出参数时， <code>return (v0, v1, ...,vn)</code> 写法可以返回多个值。不过元素的个数必须与输出参数的个数相同</p>
<h3 id="3-4-2-通过-new-创建合约"><a href="#3-4-2-通过-new-创建合约" class="headerlink" title="3.4.2 通过 new 创建合约"></a>3.4.2 通过 new 创建合约</h3><p>使用关键字 <code>new</code> 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params">uint a</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = <span class="keyword">new</span> D(<span class="number">4</span>); <span class="comment">// 将作为合约 C 构造函数的一部分执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createD</span>(<span class="params">uint arg</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        D newD = <span class="keyword">new</span> D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createAndEndowD</span>(<span class="params">uint arg, uint amount</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随合约的创建发送 ether</span></span><br><span class="line">        D newD = (<span class="keyword">new</span> D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如示例中所示，使用 <code>.value（）</code> 选项创建 <code>D</code> 的实例时可以转发 <code>Ether</code>，但是不可能限制 <code>gas</code> 的数量。如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。</p>
<h3 id="3-4-3-错误处理：Assert-Require-Revert-and-Exceptions"><a href="#3-4-3-错误处理：Assert-Require-Revert-and-Exceptions" class="headerlink" title="3.4.3 错误处理：Assert, Require, Revert and Exceptions"></a>3.4.3 错误处理：Assert, Require, Revert and Exceptions</h3><p><code>Solidity</code> 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。 便利函数 <code>assert</code> 和 <code>require</code> 可用于检查条件并在条件不满足时抛出异常。<code>assert</code> 函数只能用于测试内部错误，并检查非变量。</p>
<p> <code>require</code> 函数用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。 如果使用得当，分析工具可以评估你的合约，并标示出那些会使 <code>assert</code> 失败的条件和函数调用。 正常工作的代码不会导致一个 <code>assert</code>语句的失败；如果这发生了，那就说明出现了一个需要你修复的 bug。</p>
<p>还有另外两种触发异常的方法：<code>revert</code> 函数可以用来标记错误并恢复当前的调用。 <code>revert</code> 调用中包含有关错误的详细信息是可能的，这个消息会被返回给调用者。已经不推荐的关键字 <code>throw</code> 也可以用来替代 <code>revert()</code> （但无法返回错误消息）。</p>
<p>在下例中，你可以看到如何轻松使用<code>require</code>检查输入条件以及如何使用<code>assert</code>检查内部错误，注意，你可以给 require 提供一个消息字符串，而 assert 不行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.22</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value % <span class="number">2</span> == <span class="number">0</span>, <span class="string">"Even value required."</span>);</span><br><span class="line">        uint balanceBeforeTransfer = <span class="keyword">this</span>.balance;</span><br><span class="line">        addr.transfer(msg.value / <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。</span></span><br><span class="line">        assert(<span class="keyword">this</span>.balance == balanceBeforeTransfer - msg.value / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-合约"><a href="#3-5-合约" class="headerlink" title="3.5 合约"></a>3.5 合约</h3><p>Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</p>
<h3 id="3-5-1-创建合约"><a href="#3-5-1-创建合约" class="headerlink" title="3.5.1 创建合约"></a>3.5.1 创建合约</h3><p>可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。<br>创建合约时，会执行一次构造函数（与合约同名的函数）。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。</p>
<p>在内部，构造函数参数在合约代码之后通过 <code>ABI</code> 编码 传递，但是如果你使用 <code>web3.js</code> 则不必关心这个问题。</p>
<p>如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。</p>
<h3 id="3-5-2-getter-函数"><a href="#3-5-2-getter-函数" class="headerlink" title="3.5.2 getter 函数"></a>3.5.2 getter 函数</h3><p>编译器自动为所有 <code>public</code> 状态变量创建 <code>getter</code> 函数。对于下面给出的合约，编译器会生成一个名为 <code>data</code> 的函数， 该函数不会接收任何参数并返回一个 <code>uint</code> ，即状态变量 <code>data</code> 的值。可以在声明时完成状态变量的初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getter 函数具有外部可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果它是外部访问的（即用 this. ），它被认为为一个函数。</p>
<h3 id="3-5-3-View-函数"><a href="#3-5-3-View-函数" class="headerlink" title="3.5.3 View 函数"></a>3.5.3 View 函数</h3><p>可以将函数声明为 view 类型，这种情况下要保证不修改状态。</p>
<p>下面的语句被认为是修改状态：</p>
<ol>
<li>修改状态变量。</li>
<li>产生事件。</li>
<li>创建其它合约。</li>
<li>使用 selfdestruct。</li>
<li>通过调用发送以太币。</li>
<li>调用任何没有标记为 view 或者 pure 的函数。</li>
<li>使用低级调用。</li>
<li>使用包含特定操作码的内联汇编。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-4-Pure-函数"><a href="#3-5-4-Pure-函数" class="headerlink" title="3.5.4 Pure 函数"></a>3.5.4 Pure 函数</h3><p>函数可以声明为 pure ，在这种情况下，承诺不读取或修改状态。</p>
<p>除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取：</p>
<ol>
<li>读取状态变量。</li>
<li>访问 this.balance 或者 <address>.balance。</address></li>
<li>访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。</li>
<li>调用任何未标记为 pure 的函数。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、练习题"><a href="#四、练习题" class="headerlink" title="四、练习题"></a>四、练习题</h2><h3 id="4-1-将固定长度字节数组转化为string类型"><a href="#4-1-将固定长度字节数组转化为string类型" class="headerlink" title="4.1 将固定长度字节数组转化为string类型"></a>4.1 将固定长度字节数组转化为<code>string</code>类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract bytes32tostring&#123;</span><br><span class="line">    </span><br><span class="line">    bytes10 testword=<span class="number">0x68656c6c6f776f726c64</span>; <span class="comment">//为helloworld</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bytes32tostringF</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-实现一个带有简单逻辑判断及多种数学运算的Solidity程序"><a href="#4-2-实现一个带有简单逻辑判断及多种数学运算的Solidity程序" class="headerlink" title="4.2 实现一个带有简单逻辑判断及多种数学运算的Solidity程序"></a>4.2 实现一个带有简单逻辑判断及多种数学运算的Solidity程序</h3><p><strong>参考自：</strong></p>
<ol>
<li><p>黄皮书：<a href="https://github.com/yuange1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf" target="_blank" rel="noopener">https://github.com/yuange1024/ethereum_yellowpaper/blob/master/ethereum_yellow_paper_cn.pdf</a></p>
</li>
<li><p>白皮书：<a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/White-Paper</a><br> <a href="https://blog.csdn.net/weixin_45067603" target="_blank" rel="noopener">INlinKC</a><br> <a href="https://ethfans.org/wikis/Home" target="_blank" rel="noopener">https://ethfans.org/wikis/Home</a></p>
</li>
<li>以太坊solidity学习记录: <a href="https://blog.csdn.net/weixin_45067603/article/details/105726491" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45067603/article/details/105726491</a></li>
<li><a href="https://www.bilibili.com/video/BV1sJ411D72u" target="_blank" rel="noopener">尚硅谷区块链全套Go语言→GoWeb→以太坊→项目实战</a></li>
</ol>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>区块链入门（二）基础知识介绍</title>
    <url>/posts/fb46f828.html</url>
    <content><![CDATA[<font color="red"> 注：本教程为技术教程，不谈论且不涉及炒作任何数字货币 </font>

<p>本次组队学习重点在于以太坊基础知识、以太坊客户端以及以太坊solidity编程，因此本节教程重点在于以太坊核心知识点的掌握，区块链部分的基础知识可以作为补充，请学习者量力而行。另外若学习者觉得本节内容难度太高，可以先对基本知识点有一个概览，在第二节以及第三节实战内容学习完成之后再深入学习本节内容。</p>
<h1 id="一、区块链简介"><a href="#一、区块链简介" class="headerlink" title="一、区块链简介"></a>一、区块链简介</h1><h2 id="1-1、区块链与区块链技术"><a href="#1-1、区块链与区块链技术" class="headerlink" title="1.1、区块链与区块链技术"></a>1.1、区块链与区块链技术</h2><p>在阅读本教程之前，<a href="http://blog.codinglabs.org/articles/bitcoin-mechanism-make-easy.html" target="_blank" rel="noopener">大家对比特币原理不太了解同学可以先阅读下此博客~</a>,大家对比特币有简单了解后对于区块链会有更好的认识。</p>
<p><strong>区块链</strong>是将记录（区块）通过密码学串联并加密的链式数据结构。而<strong>区块链技术</strong>，是通过P2P网络和区块链来实现数据存储的<strong>去中心化</strong>、<strong>不可逆</strong>和<strong>不可篡改</strong>。比特币正是构建在区块链技术上的典型应用。通过区块链技术，我们可以将信息（数据、程序）保存在区块上并接入到区块链中，这样就实现了信息的去中心化存储、不可逆和不可篡改。<strong>区块链应用</strong>是指利用区块链技术开发的应用。</p>
<h2 id="1-2、区块链历史"><a href="#1-2、区块链历史" class="headerlink" title="1.2、区块链历史"></a>1.2、区块链历史</h2><p>2008年，一个网名叫中本聪（Satoshi Nakamoto）的人发表了一篇名为《比特币：一种点对点电子货币系统》的论文，论文中首次提到了“区块链”这一概念。2009年，中本聪创立了以区块链为底层技术的比特币网络，开发出了第一个区块，被称为“创世区块”。该阶段被称为“区块链1.0”。</p>
<p>由于比特币是一个电子货币系统，所以主要功能就是记账。但随后人们发现，区块链技术作为比特币的底层技术，功能可以远远不止于记账，许多关于“未知的信任”的问题，都可以通过区块链来解决，例如电子存证、信息记录等。于是在比特币的基础上，诞生了带有智能合约的区块链系统，即允许开发者通过编写智能合约来实现特定的逻辑，这一阶段被称为“区块链2.0”。这一阶段的主要代表是以太坊。</p>
<p>随后，人们想要提升区块链应用的性能，于是出现了EOS、ArcBlock等系统，其特点是高性能、大吞吐量，但由于引入了超级节点、云节点等特性，弱化了“去中心化”这一特点，因此受到较大的争议。这一阶段被称为“区块链3.0”。</p>
<p>由于比特币是一款电子货币，可扩展性较低，而所谓的“区块链3.0”目前受到较大争议，且部分项目的底层算法完全不同于典型的区块链，因此学习区块链2.0中的以太坊是目前学习区块链的最佳方式。</p>
<h2 id="1-3、区块链基础技术与算法"><a href="#1-3、区块链基础技术与算法" class="headerlink" title="1.3、区块链基础技术与算法"></a>1.3、区块链基础技术与算法</h2><p>区块链技术不是单独的一项技术，而是一系列技术组成的技术栈，其具有以下的特点：</p>
<ul>
<li>数据分布式存储</li>
<li>存储的数据不可逆、不可篡改、可回溯</li>
<li>数据的创建和维护由所有参与方共同参与</li>
</ul>
<p>为了实现这些特点、维护区块链应用的稳定运行，区块链技术中包含了分布式存储技术、密码学技术、共识机制以及区块链2.0提出的智能合约。</p>
<h3 id="1-3-1、区块"><a href="#1-3-1、区块" class="headerlink" title="1.3.1、区块"></a>1.3.1、区块</h3><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\bg2017122703.png" width="300">
</center>
<center>中心化存储</center>

<p>每个区块包含两个部分。</p>
<blockquote>
<ul>
<li>区块头（Head）：记录当前区块的特征值</li>
<li>区块体（Body）：实际数据</li>
</ul>
</blockquote>
<p>区块头包含了当前区块的多项特征值。</p>
<blockquote>
<ul>
<li>生成时间</li>
<li>实际数据（即区块体）的哈希</li>
<li>上一个区块的哈希</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="1-3-2、分布式存储技术"><a href="#1-3-2、分布式存储技术" class="headerlink" title="1.3.2、分布式存储技术"></a>1.3.2、分布式存储技术</h3><p>与传统的数据存储技术不同，在区块链技术中，数据并不是集中存放在某个数据中心上，也不是由某个权威机构或是大多数节点来存储，而是分散存储在区块链网络中的每一个节点上。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image2.png" width="300">
</center>
<center>中心化存储</center>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image3.png" width="300">
</center>
<center>分布式存储</center>

<p><strong>节点和区块的关系是什么？</strong></p>
<p>可以用共享文档来简单描述：所有可以访问共享文档的账号就叫做节点，当然全节点需要同步共享文档，也就是拥有全部的区块数据区块就是共享文档。每个人更新了，所有人都可以查看最新的文档</p>
<h3 id="1-3-3、密码学技术"><a href="#1-3-3、密码学技术" class="headerlink" title="1.3.3、密码学技术"></a>1.3.3、密码学技术</h3><p>为了实现数据的不可逆、不可篡改和可回溯，区块链技术采用了一系列密码学算法和技术，包括哈希算法、Merkle 树、非对称加密算法。</p>
<h5 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h5><p>哈希算法是一个单向函数，可以将任意长度的输入数据转化为固定长度的输出数据（哈希值），哈希值就是这段输入数据唯一的数值表现。由于在计算上不可能找到哈希值相同而输入值不同的字符串，因此两段数据的哈希值相同，就可以认为这两段数据也是相同的，所以哈希算法常被用于对数据进行验证。</p>
<p>在区块链中，数据存储在区块里。每个区块都有一个区块头，区块头中存储了一个将该区块所有数据经过哈希算法得到的哈希值，同时，每个区块中还存储了前一个区块的哈希值，这样就形成了区块链。如果想要篡改某一个区块A中的数据，就会导致A的哈希值发生变化，后一个区块B就无法通过哈希值正确地指向A，这样篡改者又必须篡改B中的数据……也就是说，篡改者需要篡改被篡改的区块以及后面的所有区块，才能让所有的节点都接受篡改。</p>
<h5 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h5><p>Merkle树是一种树形结构，在区块链中，Merkle树的叶子节点是区块中数据的哈希值，非叶子节点是其子结点组合后的哈希值，这样由叶子节点开始逐层往上计算，最终形成一个Merkle根，记录在区块的头部，这样就可以保证每一笔交易都无法篡改。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image4.png" width="500">
</center>
<center>Merkle 树</center>

<h5 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h5><p>非对称加密技术使用两个非对称密钥：公钥和私钥。公钥和私钥具有两个特点：</p>
<ol>
<li>通过其中一个密钥加密信息后，使用另一个密钥才能解开</li>
<li>公钥一般可以公开，私钥则保密</li>
</ol>
<p>在区块链中，非对称加密技术主要用于信息加密、数字签名和登录认证。在信息加密场景中，信息发送者A使用接收者B提供的公钥对信息进行加密，B收到加密的信息后再通过自己的私钥进行解密。再数字签名场景中，发送者A通过自己的私钥对信息进行加密，其他人通过A提供的公钥来对信息进行验证，证明信息确实是由A发出。在登录认证场景中，客户端使用私钥加密登录信息后进行发送，其他人通过客户端公钥来认证登录信息。</p>
<ul>
<li><p>RSA 算法</p>
<p>​        RSA加密算法是最常用的非对称加密算法，CFCA在证书服务中离不了它。但是有不少新来的同事对它不太了解，恰好看到一本书中作者用实例对它进行了简化而生动的描述，使得高深的数学理论能够被容易地理解。<br>​       RSA是第一个比较完善的公开密钥算法，它既能用于加密，也能用于数字签名。RSA以它的三个发明者Ron Rivest, Adi Shamir, Leonard Adleman的名字首字母命名，这个算法经受住了多年深入的密码分析，虽然密码分析者既不能证明也不能否定RSA的安全性，但这恰恰说明该算法有一定的可信性，目前它已经成为最流行的公开密钥算法。<br>　　RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。 </p>
</li>
<li><p>ECC 椭圆曲线算法</p>
<p>具体可以参见此文章：<a href="https://zhuanlan.zhihu.com/p/36326221" target="_blank" rel="noopener">ECC椭圆曲线加密算法：介绍</a></p>
</li>
</ul>
<h3 id="1-3-4、共识机制"><a href="#1-3-4、共识机制" class="headerlink" title="1.3.4、共识机制"></a>1.3.4、共识机制</h3><p>区块链系统是一个分布式系统，分布式系统要解决都首要问题就是一致性问题，也就是如何使多个孤立的节点达成共识。在中心化系统中，由于有一个中心服务器这样的“领导”来统一各个节点，因此达成一致性几乎没有问题。但在去中心化场景下，由于各个节点是相互独立的，就可能会出现许多不一致的问题，例如由于网络状况等因素部分节点可能会有延迟、故障甚至宕机，造成节点之间通信的不可靠，因此一致性问题是分布式系统中一个很令人头疼的问题。</p>
<p>由 Eirc Brewer 提出，Lynch 等人证明的 CAP 定理为解决分布式系统中的一致性问题提供了思路。CAP 定理的描述如下：在分布式系统中，<strong>一致性</strong>、<strong>可用性</strong>和<strong>分区容错性</strong>三者不可兼得。这三个术语的解释如下：</p>
<ul>
<li>一致性（<strong>C</strong>onsistency）：所有节点在同一时刻拥有同样的值（等同于所有节点访问同一份最新的数据副本</li>
<li>可用性（<strong>A</strong>vailability）：每个请求都可以在有限时间内收到确定其是否成功的响应</li>
<li>分区容错性（<strong>P</strong>artition tolerance）：分区是指部分节点因为网络原因无法与其他节点达成一致。分区容错性是指由网络原因导致的系统分区不影响系统的正常运行。例如，由于网络原因系统被分为 A, B, C, D 四个区，A, B 中的节点无法正常工作，但 C, D 组成的分区仍能提供正常服务。</li>
</ul>
<p>在某些场景下，对一致性、可用性和分区容错性中的某一个特性要求不高时，就可以考虑弱化该特性，来保证整个系统的容错能力。区块链中常见的共识机制的基本思路正是来自 CAP 定理，部分区块链应用中用到的共识机制如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>共识机制</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PoW</td>
<td>比特币、莱特币、以太坊的前三个阶段</td>
</tr>
<tr>
<td>PoS</td>
<td>PeerCoin、NXT、以太坊的第四个阶段</td>
</tr>
<tr>
<td>PBFT</td>
<td>Hyperledger Fabric</td>
</tr>
</tbody>
</table>
</div>
<h5 id="PoW（Proof-of-Work，工作量证明）"><a href="#PoW（Proof-of-Work，工作量证明）" class="headerlink" title="PoW（Proof of Work，工作量证明）"></a>PoW（Proof of Work，工作量证明）</h5><p>PoW 机制的大致流程如下：</p>
<ol>
<li>向所有节点广播新交易和一个数学问题</li>
<li>最先解决了数学问题的节点将交易打包成区块，对全网广播</li>
<li>其他节点验证广播区块的节点是否解决了数学问题（完成了一定的工作量），验证通过则接受该区块，并将该区块的哈希值放入下一个区块中，表示承认该区块</li>
</ol>
<p>由于在 PoW 机制中，区块的产生需要解决一个数学问题，也就是所谓的<strong>挖矿</strong>，这往往要消耗较大的算力和电力，因此节点们倾向于在<strong>最长的链</strong>的基础上添加区块，因为如果节点想在自己的链上添加新的区块，那么就需要重新计算 1 个或 $n$ 个这样的数学问题（每添加一个区块就需要计算一个）。因此在比特币中最长的链被认为是合法的链，这样节点间就形成了一套“共识”。</p>
<p>PoW 机制的优点是完全去中心化，缺点是需要依赖数学运算，资源的消耗会比其他的共识机制高，可监管性弱，同时每次达成共识需要全网共同参与运算，性能较低。</p>
<h5 id="PoS（Proof-of-Stack，股权证明）"><a href="#PoS（Proof-of-Stack，股权证明）" class="headerlink" title="PoS（Proof of Stack，股权证明）"></a>PoS（Proof of Stack，股权证明）</h5><p>PoS 针对 PoW 的缺点做出了改进。PoS 要求参与者预先放置一些货币在区块链上用于换取“股权”，从而成为<strong>验证者（Validator）</strong>，验证者具有产生区块的权利。PoS 机制会按照存放货币的量和时间给验证者分配相应的利息，同时还引入了奖惩机制，打包错误区块的验证者将失去他的股权——即投入的货币以及产生区块的权利。PoS 机制的大致流程如下：</p>
<ol>
<li>加入 PoS 机制的都是持币人，称为验证者</li>
<li>PoS 算法根据验证者持币的多少在验证者中挑选出一个给予产生区块的权利</li>
<li>如果一定时间内没有产生区块，PoS 就挑选下一个验证者，给予产生区块的权利</li>
<li>如果某个验证者打包了一份欺诈性交易，PoS 将剥夺他的股权</li>
</ol>
<p>PoS 的优点在于：</p>
<ol>
<li>引入了利息，使得像比特币这样发币总数有限的通货紧缩系统在一定时间后不会“无币可发”</li>
<li>引入了奖惩机制使节点的运行更加可控，同时更好地防止攻击</li>
<li>与 PoW 相比，不需要为了生成新区块而消耗大量电力和算力</li>
<li>与 PoW 相比，缩短了达成共识所需的时间</li>
</ol>
<p>由于 PoS 机制需要用户已经持有一定数量的货币，没有提供在区块链应用创立初始阶段处理数字货币的方法，因此使用 PoS 机制的区块链应用会在发布时预先出售货币，或在初期采用 PoW，让矿工获得货币后再转换成 PoS，例如以太坊现阶段采用的是 PoW 机制，在第四阶段“宁静”（Serenity）中将过渡到 PoS。</p>
<h5 id="拜占庭将军问题（Byzantine-Generals-Problem）"><a href="#拜占庭将军问题（Byzantine-Generals-Problem）" class="headerlink" title="拜占庭将军问题（Byzantine Generals Problem）"></a>拜占庭将军问题（Byzantine Generals Problem）</h5><p>拜占庭将军问题是分布式网络中的通信容错问题，可以描述为：</p>
<blockquote>
<p>一组拜占庭将军各领一支队伍共同围困一座城市。各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻而部分军队撤离可能会造成灾难性的后果，因此各将军决定通过投标来达成一致策略，即“共进退”。因为各将军位于城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己的选择（进攻或撤退）通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同投票的结果，进而做出行动。</p>
</blockquote>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image1.png" width="500">
</center>



<p>拜占庭将军的问题在于，将军中可能出现叛徒。假设3名将军中有1名叛徒，2名忠诚将军一人投进攻票，一人投撤退票，这时叛徒可能会故意给投进攻的将军投进攻票，而给投撤退的将军投撤退票。这就导致一名将军带队发起进攻，而另外一名将军带队撤退。</p>
<p>另外，由于将军之间通过信使进行通讯，即使所有将军都忠诚，也不能排除信使被敌人截杀，甚至信使叛变等情况。</p>
<p>假设存在叛变将军或信使出问题等情况，如果忠诚将军仍然能够通过投票来决定他们的战略，便称系统达到了<strong>拜占庭容错（Byzantine Fault Tolerance）</strong>。</p>
<p>拜占庭问题对应到区块链中，将军就是节点，信使就是网络等通信系统，要解决的是存在恶意节点、网络错误等情况下系统的一致性问题。</p>
<p><strong>PBFT（Practical Byzantine Fault Tolerance）</strong> 是第一个得到广泛应用且比较高效的拜占庭容错算法，能够在节点数量不小于 $n=3f+1$ 的情况下容忍 $f$ 个拜占庭节点（恶意节点）。</p>
<h1 id="二、以太坊介绍"><a href="#二、以太坊介绍" class="headerlink" title="二、以太坊介绍"></a>二、以太坊介绍</h1><p>首先我们要知道我们为什么要学习以太坊，主要有以下四个原因：</p>
<ul>
<li>以太坊是区块链2.0的代表，学习以太坊能了解到区块链技术的所有知识</li>
<li>引入了智能合约，拓宽了区块链的应用场景</li>
<li>对开发者友好、对用户友好，容易编写出简单的区块链应用，学习趣味性高</li>
<li>Solidity 语法与 Javascript、Go 等语言接近，易上手</li>
</ul>
<h2 id="2-1、以太坊简介"><a href="#2-1、以太坊简介" class="headerlink" title="2.1、以太坊简介"></a>2.1、以太坊简介</h2><p>区块链技术常常被认为是自互联网诞生以来最具颠覆性的技术，然而，自比特币诞生后一直没有很好的区块链应用开发平台。想要在比特币基础上开发区块链应用是非常复杂繁琐的，因为比特币仅仅是一个加密数字货币系统，无法用来实现更广阔的业务需求。以太坊是目前使用最广泛的支持完备应用开发的共有区块链系统。</p>
<p>和比特币不同，比特币只适合加密数字货币场景，不具备图灵完备性，也缺乏保存实时状态的账户概念，以及存在 PoW 机制带来的效率和资源浪费的问题，而以太坊作为区块链2.0的代表，目标是扩展智能合约和建立一个去中心化应用平台，具有图灵完备的特性、更高效的共识机制、支持智能合约等多种应用场景，使得开发者能够很方便地在以太坊上开发出基于区块链的应用。</p>
<h3 id="2-1-1、以太坊的发展"><a href="#2-1-1、以太坊的发展" class="headerlink" title="2.1.1、以太坊的发展"></a>2.1.1、以太坊的发展</h3><p>2014年， Vitalik Buterin 发表了文章《以太坊：一个下一代智能合约和去中心化应用平台》。同年，Buterin 在迈阿密比特币会议中宣布启动以太坊项目，并提出了多项创新性的区块链技术。2015年，以太坊CCO Stephan Tual 在官方博客上宣布以太坊系统诞生，主网上线。</p>
<p>以太坊发展至今经历了“前沿”（Frontier）、“家园”（Homestead）以及现在所处的“大都会”（Metropolis）三个阶段。第四阶段“宁静”（Serenity）将作为以太坊的最后一个阶段，目前尚未有计划发布日期。</p>
<h3 id="2-1-2、以太坊的特点"><a href="#2-1-2、以太坊的特点" class="headerlink" title="2.1.2、以太坊的特点"></a>2.1.2、以太坊的特点</h3><p>以太坊团队和外界对以太坊的描述都是“世界计算机”，这代表它是一个开源的、全球的去中心化计算架构。它执行称为智能合约的程序，并使用区块链来同步和存储系统状态，以及使用名为以太币的加密数字货币来计量和约束执行操作的资源成本。同时，以太坊提供了一系列的接口，使得开发者能够通过以太坊来开发去中心化 Web 应用DApps。</p>
<h3 id="2-1-3、智能合约"><a href="#2-1-3、智能合约" class="headerlink" title="2.1.3、智能合约"></a>2.1.3、智能合约</h3><p>相比比特币，以太坊最大的特点就是引入了<strong>智能合约</strong>。智能合约本质上就是一段编写好的程序，可以在特定的条件下被触发并执行特定的操作。由于区块链具有不可逆和不可篡改的特点，因此智能合约与区块链结合后，就成了一份“强制执行”的合约。</p>
<p>以太坊能够作为一个去中心化应用平台和”世界计算机”，其核心就是智能合约。智能合约的引入，使得开发者能够实现许多（理论上是任何）业务逻辑。如果说比特币是通过区块链技术开发的特定计算器，那么引入了智能合约的以太坊就是基于区块链技术的通用计算机。可以简单的理解成：比特币的交易系统就是一份写死的智能合约，而以太坊则将智能合约的开发权限交给开发者。</p>
<p>以太坊提供了对智能合约的全面支持，包括编写智能合约编程语言 <strong>Solidity</strong> 和运行智能合约的<strong>以太坊虚拟机（Ethereum Virtual Machine，EVM）</strong>。</p>
<h3 id="2-1-4、幽灵协议"><a href="#2-1-4、幽灵协议" class="headerlink" title="2.1.4、幽灵协议"></a>2.1.4、幽灵协议</h3><p>幽灵合约的英文是“Greedy Heaviest Observed Subtree” (GHOST) protocol，在介绍幽灵协议之前，先介绍以太坊中的叔区块、叔块奖励和叔块引用奖励这三个概念。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image5.png" width="400">
</center>


<p>假设目前以太坊区块链中的区块高度（区块链上的区块个数）为6，现在产生了一笔新的交易，矿工A先将该笔交易打包成了区块 Block 7，在矿工A将 Block 7 广播到其他节点的这段时间里，矿工B和矿工C又分别产生了 Block 8 和 Block 9。Block 7、Block 8、Block 9 都指向 Block 6，即 Block 6 是他们的父区块。由于 Block 7 是最先产生的，因此 Block 7 被认为是有效区块，Block 8 和 Block 9 就是<strong>叔区块</strong>（作废区块）。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image6.png" width="300">
</center>


<p>现在链上的区块高度为7，在这基础上又产生了新的交易，并被打包成了 Block 10。在以太坊中，Block 10 除了可以引用它的父区块 Block 7 外，还可以引用叔区块 Block 8 和 Block 9。并且，Block 8 和 Block 9 的矿工会因此获得一笔奖励，称为<strong>叔块奖励</strong>，Block 10 的矿工除了基础奖励之外，由于引用了叔区块，还会获得一笔额外的<strong>叔块引用奖励</strong>。</p>
<p><strong>幽灵协议</strong>是以太坊的一大创新。由于在比特币中的出块时间被设计为10分钟，而以太坊为了提高出块速度，将出块时间设计为12秒（实际14~15秒左右），这样的高速出块意味着高速确认，高速确认会带来区块的<strong>高作废率</strong>和<strong>低安全性</strong>。因为区块需要花一定的时间才能广播至全网，如果矿工 A 挖出了一个区块，而矿工 B 碰巧在 A 的区块扩散至 B 之前挖出了另一个区块，矿工 B 的区块就会作废并且没有对区块链的网络安全做出贡献。此外，这样的高速确认还会带来<strong>中心化</strong>的问题：如果 A 拥有全网 30% 的算力而 B 拥有 10% 的算力，那么 A 将会在 70% 的时间内都在产生作废区块，而 B 在 90% 的时间内都在产生作废区块，这样，B 永远追不上 A，后果是 A 通过其算力份额拥有对挖矿过程实际上的控制权，出现了算力垄断，弱化了去中心化。</p>
<p>幽灵协议正是为了解决上述问题而引入的，协议的主要内容如下：</p>
<ul>
<li>计算最长链时，不仅包括当前区块的父区块和祖区块，还包括祖先块的作废的后代区块（叔区块），将它们综合考虑来计算哪一个区块拥有支持其的最大工作量证明。这解决了网络安全性的问题</li>
<li>以太坊付给以“叔区块”身份为新块确认作出贡献的废区块87.5%的奖励（叔块奖励），把它们纳入计算的“侄子区块”将获得奖励的12.5%（叔块引用奖励）。这就使得即使产生作废区块的矿工也能够参与区块链网络贡献并获得奖励，解决了中心化倾向的问题</li>
<li>叔区块最深可以被其父母的第二代至第七代后辈区块引用。这样做是为了：<ul>
<li>降低引用叔区块的计算复杂性</li>
<li>过多的叔块引用奖励会剥夺矿工在主链上挖矿的激励，使得矿工有转向公开攻击者链上挖矿的倾向（即公开攻击者可能会恶意产生大量作废区块，无限引用将会诱使矿工转移到攻击者的链上，从而抛弃合法的主链）</li>
<li>计算表明带有激励的五层幽灵协议即使在出块时间为15s的情况下也实现了了95%以上的效率，而拥有25%算力的矿工从中心化得到的益处小于3%</li>
</ul>
</li>
</ul>
<h3 id="2-1-5、以太坊的组成部分"><a href="#2-1-5、以太坊的组成部分" class="headerlink" title="2.1.5、以太坊的组成部分"></a>2.1.5、以太坊的组成部分</h3><p>在以太坊中，包括了 P2P 网络、共识机制、交易、状态机、客户端这几个组成部分。</p>
<ul>
<li>P2P 网络：在以太坊主网上运行，可通过TCP端口30303访问，并运行称为 ÐΞVp2p 的协议。</li>
<li>共识机制：以太坊目前使用名为 Ethash 的 POW 算法，计划在将来会过渡到称为 Casper 的 POS 算法。</li>
<li>交易：以太坊中的交易本质上是网络消息，包括发送者、接收者、值和数据载荷（payload）。</li>
<li>状态机：以太坊的状态转移由以太坊虚拟机（Ethereum Virtual Machine，EVM）处理，EVM 能够将智能合约编译成机器码并执行。</li>
<li>客户端：用于用户和以太坊进行交互操作的软件实现，最突出的是 Go-Ethereum(Geth) 和 Parity。</li>
</ul>
<h3 id="2-1-6、以太坊中的概念"><a href="#2-1-6、以太坊中的概念" class="headerlink" title="2.1.6、以太坊中的概念"></a>2.1.6、以太坊中的概念</h3><ul>
<li>账户：以太坊中的账户类似于银行账户、应用账户，每个账户有一个20字节的地址。账户又分为<strong>普通账户</strong>（又叫外部账户，External Owned Account, EOA）和<strong>合约账户</strong>（Contract）。普通账户是由以太坊使用者创建的账户，包含地址、余额和随机数；合约账户是创建智能合约时建立的账户，包含存储空间和合约代码</li>
<li>状态：状态是由账户和两个账户之间价值的转移以及信息的状态转换构成的</li>
<li>地址：地址是一个账户 ECDSA 公钥的 Keccak 散列最右边的160位，通过地址可以在以太坊上接收或发送交易。在 Etherscan 上，可以通过地址来查询一个账户的信息</li>
<li>交易：以太坊中的交易不仅包括发送和接收以太币，还包括向合约账户发送交易来调用合约代码、向空用户发送交易来生成以交易信息为代码块的合约账户</li>
<li>Gas：Gas 是以太坊中的一种机制，用于执行智能合约或交易操作的虚拟燃料。由于以太坊是图灵完备的，为了避免开发者无意或恶意编写出死循环等浪费资源或滥用资源的情况，以太坊中的每一笔交易都需支付一定的 Gas （燃料费），即需支付一定的以太币作为 Gas。Gas 的金额通常是由交易的发起者指定并支付的</li>
<li>挖矿：和比特币类似，以太坊同样通过挖矿来产生区块。在以太坊目前的 PoW 机制下，每当一笔交易发出并广播，就会吸引矿工来将该交易打包成区块。每产生一个区块都会有一笔<strong>固定奖励</strong>给矿工，目前的固定奖励是3个以太。同时，区块中所有操作所需的 Gas 也会作为奖励给矿工。与比特币不同的是，以太坊中产生叔块的矿工可能会获得叔块奖励，引用叔块的矿工会获得叔块引用奖励</li>
<li>DApp（去中心化应用）：通过智能合约，开发者能够设计想要的逻辑，相当于是网站的后端。而 DApp 则相当于是一个完整的网站（前端+后端），因此 DApp = 智能合约 + Web 前端。以太坊提供了一个名为 web3.js 的 Javascript 库，通过 web3.js 可以实现 Web 与以太坊区块链的交互和与智能合约的交互，方便开发者创建 DApp</li>
</ul>
<h2 id="2-2、以太坊基础"><a href="#2-2、以太坊基础" class="headerlink" title="2.2、以太坊基础"></a>2.2、以太坊基础</h2><h3 id="2-2-1、以太坊中的货币"><a href="#2-2-1、以太坊中的货币" class="headerlink" title="2.2.1、以太坊中的货币"></a>2.2.1、以太坊中的货币</h3><p>以太坊中的货币称为 <strong>以太币</strong>，单位为<strong>以太（Ether）</strong>，也称 ETH 或符号 Ξ。以太可以被分割为更小的单位，最小的单位是 wei，1 以太 =  $10^18$  wei。以太币各单位的名称及之间的关系如下表：</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219000835894.png">
</center>





<h3 id="2-2-2、以太坊钱包"><a href="#2-2-2、以太坊钱包" class="headerlink" title="2.2.2、以太坊钱包"></a>2.2.2、以太坊钱包</h3><p>以太坊钱包是用于创建和广播交易的应用程序，常用的钱包有</p>
<ul>
<li>MetaMask，一款基于浏览器扩展的钱包，可以很方便地添加到 Chrome, FireFox 等支持扩展的浏览器中</li>
<li>Jaxx，一款跨平台、多币种的钱包</li>
<li>MyEtherWallet(MEW)，一款基于 Web 的钱包，可以在任何浏览器中运行</li>
<li>Emerald Wallet，一款被设计来用于以太坊经典区块链的钱包，但也与其他以太坊区块链兼容</li>
</ul>
<h4 id="MetaMask-基础"><a href="#MetaMask-基础" class="headerlink" title="MetaMask 基础"></a>MetaMask 基础</h4><p>以 Chrome 为例，访问 <a href="https://chrome.google.com/webstore/category/extensions" target="_blank" rel="noopener">Google 网上应用商店</a>，搜索 MetaMask 并添加至 Chrome</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101124978.png">
</center>


<p>添加完成后 Chrome 会自动打开初始化页面</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101226095.png">
</center>



<p>初次使用创建钱包</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101300792.png">
</center>



<p>为钱包设置密码</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101332089.png">
</center>




<p>创建密码后，MetaMask 会生成一串密语，密语是12个随机的英文单词，用于防止密码忘记。密语可以直接当成密码使用，因此需要妥善保管</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219102028033.png">
</center>



<p>注册完毕后就可以在 Chrome 地址栏右边的扩展程序栏点击 🦊 图标使用 MetaMask 了</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219102255927.png">
</center>

<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219102322360.png">
</center>

<h4 id="获取测试以太"><a href="#获取测试以太" class="headerlink" title="获取测试以太"></a>获取测试以太</h4><p>除了以太坊主网以外，以太坊还提供了 Ropsten, Kovan, Rinkeby, Goerli 这几个公共测试网络，另外还支持局域网测试网络和自建测试网络。在这里我们切换到 Ropsten 测试网络</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219105616335.png">
</center>




<p>随后点击 <strong>Buy</strong> 按钮，点击<strong>测试水管</strong>下方的获取以太</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219105824087.png">
</center>




<p>在打开的页面中点击 request 1 ether from faucet 就可以得到1个测试以太，当然，可以多次点击。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219105911910.png">
</center>


<center class="half">
    <img src="\Pic\Blockchain_Pic\2021-02-19_110327.png">
</center>


<p>测试以太仅供测试使用，除此之外没有任何价值，测试完毕后剩下的以太可以发送到水龙头账户捐赠给水龙头，以供他人测试使用。</p>
<h2 id="2-3、以太坊交易的数据结构"><a href="#2-3、以太坊交易的数据结构" class="headerlink" title="2.3、以太坊交易的数据结构"></a>2.3、以太坊交易的数据结构</h2><p>在以太坊网络中，交易执行属于一个事务。具有原子性、一致性、隔离性、持久性特点。</p>
<ul>
<li>原子性： 是不可分割的最小执行单位，要么做，要么不做。</li>
<li>一致性： 同一笔交易执行，必然是将以太坊账本从一个一致性状态变到另一个一致性状态。</li>
<li>隔离性： 交易执行途中不会受其他交易干扰。</li>
<li>持久性： 一旦交易提交，则对以太坊账本的改变是永久性的。后续的操作不会对其有任何影响。</li>
</ul>
<p>以太坊交易的本质是由外部拥有的账户发起的签名消息，由以太坊网络传输，并被序列化后记录在以太坊区块链上，<strong>交易是唯一可以触发状态更改或导致合约在EVM中执行的事物</strong></p>
<h3 id="2-3-1、交易的数据结构"><a href="#2-3-1、交易的数据结构" class="headerlink" title="2.3.1、交易的数据结构"></a>2.3.1、交易的数据结构</h3><p>以太坊的数据结构主要可以分为四部分：<code>nonce</code>、<code>gas</code>、交易目标和消息（主要部分）、交易签名</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\transaction-struct.png">
</center>



<p>开头是一个 uint64 类型的数字，称之为随机数。用于撤销交易、防止双花和修改以太坊账户的 Nonce 值。</p>
<p>第二部分是关于交易执行限制的设置，gas 为愿意供以太坊虚拟机运行的燃料上限。 <code>gasPrice</code> 是愿意支付的燃料单价。<code>gasPrcie * gas</code> 则为愿意为这笔交易支付的最高手续费。</p>
<p>第三部分是交易发送者输入以太坊虚拟机执行此交易的初始信息： 虚拟机操作对象（接收方 To）、从交易发送方转移到操作对象的资产（Value），以及虚拟机运行时入参(input)。其中 To 为空时，意味着虚拟机无可操作对象，<strong>此时虚拟机将利用 input 内容部署一个新合约</strong>。</p>
<p>第四部分是交易发送方对交易的签名结果，可以利用交易内容和签名结果反向推导出签名者，即交易发送方地址。以上总结如下：</p>
<ul>
<li><code>nonce</code>：由发起人EOA发出的序列号，用于防止交易消息重播。</li>
<li><code>gas price</code>：交易发起人愿意支付的gas单价（wei）。</li>
<li><code>start gas</code>：交易发起人愿意支付的最大gas量。</li>
<li><code>to</code>：目的以太坊地址。</li>
<li><code>value</code>：要发送到目的地的以太数量。</li>
<li><code>data</code>：可变长度二进制数据负载（payload）。</li>
<li><code>v,r,s</code>：发起人EOA的ECDSA签名的三个组成部分。</li>
<li>交易消息的结构使用递归长度前缀（RLP）编码方案进行序列化，该方案专为在以太坊中准确和字节完美的数据序列化而创建。</li>
</ul>
<h3 id="2-3-2、交易中的nonce"><a href="#2-3-2、交易中的nonce" class="headerlink" title="2.3.2、交易中的nonce"></a>2.3.2、交易中的<code>nonce</code></h3><p>按以太坊黄皮书的定义， <code>nonce</code>是一个标量值，它等于从这个地址发送的交易数，或者对于关联code的帐户来说，是这个帐户创建合约的数量。因此<code>nonce</code>便有以下特征：</p>
<ul>
<li><code>nonce</code>不会明确存储为区块链中帐户状态的一部分。相反，它是通过计算发送地址的已确认交易的数量来动态计算的。</li>
<li><code>nonce</code>值还用于防止错误计算账户余额。<code>nonce</code>强制来自任何地址的交易按顺序处理，没有间隔，无论节点接收它们的顺序如何。</li>
<li>使用<code>nonce</code>确保所有节点计算相同的余额和正确的序列交易，等同于用于防止比特币“双重支付”（“重放攻击”）的机制。但是，由于以太坊跟踪账户余额并且不单独跟踪 <code>UTXO</code> ，因此只有在错误地计算账户余额时才会发生“双重支付”。<code>nonce</code>机制可以防止这种情况发生。</li>
</ul>
<h3 id="2-3-3、并发和nonce"><a href="#2-3-3、并发和nonce" class="headerlink" title="2.3.3、并发和nonce"></a>2.3.3、并发和<code>nonce</code></h3><p>以太坊是一个允许操作（节点，客户端，DApps）并发的系统，但强制执行单例状态。例如，出块的时候只有一个系统状态。假如我们有多个独立的钱包应用或客户端，比如 MetaMask 和 Geth，它们可以使用相同的地址生成交易。如果我们希望它们都够同时发送交易，该怎么设置交易的<code>nonce</code>呢？一般有以下两种做法：</p>
<ul>
<li>用一台服务器为各个应用分配<code>nonce</code>，先来先服务——可能出现单点故障，并且失败的交易会将后续交易阻塞。</li>
<li>生成交易后不分配<code>nonce</code>，也不签名，而是把它放入一个队列等待。另起一个节点跟踪<code>nonce</code>并签名交易。同样会有单点故障的可能，而且跟踪<code>nonce</code>和签名的节点是无法实现真正并发的。</li>
</ul>
<h3 id="2-3-4、交易中的gas"><a href="#2-3-4、交易中的gas" class="headerlink" title="2.3.4、交易中的gas"></a>2.3.4、交易中的<code>gas</code></h3><p>Gas 中译是：瓦斯、汽油，代表一种可燃气体。 这形象地比喻以太坊的交易手续费计算模式，不同于比特币中<strong>直接</strong>支付比特币作为转账手续费， 以太坊视为一个去中心化的计算网络，当你发送Token、执行合约、转移以太币或者在此区块上干其他的时候，计算机在处理这笔交易时需要进行计算消耗网络资源，这样你必须支付燃油费购买燃料才能让计算机为你工作。最终燃料费作为手续费支付给矿工。</p>
<blockquote>
<p>注：可以在Etherscan上查询gas price与confirmation time的关系，如下图</p>
</blockquote>
<center class="half">
    <img src="\Pic\Blockchain_Pic\gas.jpg">
</center>


<p>因为手续费等于<code>gasPrice * gasUsed</code>，用户在转账，特别是执行智能合约时 gasUsed 无法提前预知。 这样存在一个风险，当用户的交易涉及一个恶意的智能合约，该合约执行将消耗无限的燃料， 这样会导致交易方的余额全部消耗（恶意的智能合约有可能是程序Bug，如合约执行陷入一个死循环）。</p>
<p>为了避免合约中的错误引起不可预计的燃料消耗，用户需要在发送交易时设定允许消耗的燃料上限，即 gasLimit。 这样不管合约是否良好，最坏情况也只是消耗 gasLimit 量的燃料。</p>
<p>然而，一笔交易所必须支付的燃料已经在区块中通过该交易已执行的计算量记录。 如果你不想支出太多燃料，而故意设置过低的 gasLimit 是没太多帮助的。 你必须支付足够燃料来支付本交易所必要的计算资源。如果交易尚未执行完成，而燃料已用完， 将出现一个 <code>Out of Gas</code> 的错误。特别注意的是，即使交易失败，你也必须为已占用的计算资源所支付手续费。 比如，你通过合约给 TFBOYS 投票，设置 gasPrice=2 gwei，gasLimit=40000（实现投票需要40001的燃料开销）， 最终你投票失败且仍然需要支付 40000*2 gwei= 80000 gwei= 0.00008 ETH。</p>
<p>另外，如果最终 gasUsed 低于 gasLimit，即燃料未用完。则剩余燃料(gasLimit - gasUsed )将在交易后退还给你。 比如你发送 1 Ether 到另一个账户B，设置 gas limit 为 400000，将有 400000 - 21000 返回给你。</p>
<blockquote>
<p>注意：21000 是标准转账交易的gasUsed。因此一笔标准的转账交易你可以设置 gasLimit 为21000</p>
</blockquote>
<h2 id="2-4、以太坊账户"><a href="#2-4、以太坊账户" class="headerlink" title="2.4、以太坊账户"></a>2.4、以太坊账户</h2><p>对比比特币的UTXO余额模型，以太坊使用“账户”余额模型。 以太坊丰富了账户内容，除余额外还能自定义存放任意多数据。 并利用账户数据的可维护性，构建智能合约账户。下面我们首先将比特币的UTXO余额模型与以太坊账户进行比较，说明其各自的优缺点以及适用性。</p>
<h3 id="2-4-1、比特币UTXO和以太坊账户结构比较"><a href="#2-4-1、比特币UTXO和以太坊账户结构比较" class="headerlink" title="2.4.1、比特币UTXO和以太坊账户结构比较"></a>2.4.1、比特币UTXO和以太坊账户结构比较</h3><p>在当前的区块链项目中，主要有两种记录保存方式，<strong>一种是账户/余额模型，一种是UTXO模型</strong>。比特币采用就是UTXO模型，以太坊、EOS等则采用的是账户/余额模型。</p>
<p><img src="\Pic/utxo_com.jpg" style="zoom:67%;"></p>
<h3 id="2-4-2、比特币UTXO"><a href="#2-4-2、比特币UTXO" class="headerlink" title="2.4.2、比特币UTXO"></a>2.4.2、比特币UTXO</h3><p>UTXO是 Unspent Transaction Output的缩写，意思是<strong>未花费的输出，</strong>可以简单理解为还没有用掉的收款。比如韩梅梅收到一笔比特币，她没有用掉，这笔比特币对她来说就是一个UTXO。关于UTXO的具体介绍大家可以查看<a href="https://zhuanlan.zhihu.com/p/74050135" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><strong>UTXO 核心设计思路是：它记录交易事件，而不记录最终状态。</strong>要计算某个用户有多少比特币，就要对其钱包里所有的UTXO求和，得到结果就是他的持币数量。UTXO模型在转账交易时，是以UTXO为单位的，也就是说在支付时，调用的是整数倍UTXO，比如1个UTXO，3个UTXO，没有0.5个UTXO的说法。</p>
<ul>
<li>比特币在基于UTXO的结构中存储有关用户余额的数据，系统的整个状态就是一组UTXO的集合，每个UTXO都有一个所有者和一个面值（就像不同的硬币），而交易会花费若干个输入的UTXO，并根据规则创建若干个新的UTXO</li>
<li>每个引用的输入必须有效并且尚未花费，对于一个交易，必须包含有每个输入的所有者匹配的签名，总输入必须大于等于总输出值。所以系统中用户的余额是用户具有私钥的UTXO的总值</li>
</ul>
<h3 id="2-4-3、以太坊账户"><a href="#2-4-3、以太坊账户" class="headerlink" title="2.4.3、以太坊账户"></a>2.4.3、以太坊账户</h3><p>为什么以太坊不用UTXO呢？显然是因为麻烦，以太坊的做法更符合直觉，以太坊中的状态就是系统中所有账户的列表，每个账户都包含了一个余额和以太坊<strong>特殊定义的数据</strong>（代码和内部存储）。如果发送账户有足够多的余额来进行支付，则交易有效，在这种情况下发送账户先扣款，而收款账户将记入这笔收入。<strong>如果接受账户有相关代码，则代码会自动运行，并且它的内部存储也可能被更改，或者代码还可能向其他账户发送额外的消息，这就会导致进一步的借贷资金关系。</strong></p>
<h3 id="2-4-4、优缺点比较"><a href="#2-4-4、优缺点比较" class="headerlink" title="2.4.4、优缺点比较"></a>2.4.4、优缺点比较</h3><p><strong>比特币UTXO的优点</strong>：</p>
<ul>
<li>更高程度的隐私：如果用户为他们收到的每笔交易使用新地址，那么通常很难将账户互相链接。这很大程度上适用于货币，但不太适用于任何dapps，因为dapps通常涉及跟踪和用户绑定的复杂状态，可能不存在像货币那样简单的用户状态划分方案</li>
<li>潜在的可扩展性：UTXO在理论上更符合可扩展性要求，因为我们只需要依赖拥有UTXO的那些人去维护基于Merkle树的所有权证明就够了，即使包括所有者在内的每个人都决定忘记该数据，那么也只有所有者受到对应的UTXO的损失，不影响接下来的交易。而在账户模式中，如果每个人都丢失了与账户相对应的Merkle树的部分，那将会使得和该账户有关的消息完全无法处理，包括发币给它。</li>
</ul>
<p><strong>以太坊账户模式的优点</strong>：</p>
<ul>
<li>可以节省大量空间：不将UTXOs分开存储，而是合成一个账户；每个交易只需要一个输入、一个签名并产生一个输出</li>
<li>更好的可替代性：货币本质上都是同质化、可替代的；UTXO的设计使得货币从来源分成了“可花费”和“不可花费”两类，这在实际应用中很难有对应模型</li>
<li>更加简单：更容易编码和理解，特别是设计复杂脚本的时候，UTXO的脚本逻辑复杂时更令人费解</li>
<li>便于维护持久轻节点：只要沿着特定方向扫描状态树，轻节点 可以很容易地随时访问账户相关的所有数据。而UTXO地每个交易都会使得状态引用发生改变，这对应节点来说长时间运行Dapp会有很大压力</li>
</ul>
<h3 id="2-4-5、总结"><a href="#2-4-5、总结" class="headerlink" title="2.4.5、总结"></a>2.4.5、总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>BitCoin</th>
<th>Ethereum</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设计定位</strong></td>
<td>现金系统</td>
<td>去中心化应用平台</td>
</tr>
<tr>
<td><strong>数据组成</strong></td>
<td>交易列表（账本）</td>
<td>交易和账户状态</td>
</tr>
<tr>
<td><strong>交易对象</strong></td>
<td>UTXO</td>
<td>Accounts</td>
</tr>
<tr>
<td><strong>代码控制</strong></td>
<td>脚本</td>
<td>智能合约</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-5、以太坊账户类型"><a href="#2-5、以太坊账户类型" class="headerlink" title="2.5、以太坊账户类型"></a>2.5、以太坊账户类型</h2><p>以太坊作为智能合约操作平台，将账户划分为两类：外部账户（EOAs）和合约账户（contract account），下面分别做简要介绍：</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\EOA_CA.png">
</center>



<h3 id="2-5-1、外部账户（EOA）"><a href="#2-5-1、外部账户（EOA）" class="headerlink" title="2.5.1、外部账户（EOA）"></a>2.5.1、外部账户（EOA）</h3><p>外部账户是由人来控制的，也就是常规理解的普通账户，外部账户包含以太币余额，主要作用就是发送交易（是广义的交易，包括转币和触发合约代码），是由用户私钥控制的，没有关联代码，所有在以太坊上交易的发起者都是外部账户。</p>
<p>外部账户特点总结：</p>
<ol>
<li>拥有以太余额。</li>
<li>能发送交易，包括转账和执行合约代码。</li>
<li>被私钥控制。</li>
<li>没有相关的可执行代码。</li>
</ol>
<h3 id="2-5-2、合约账户（CA）"><a href="#2-5-2、合约账户（CA）" class="headerlink" title="2.5.2、合约账户（CA）"></a>2.5.2、合约账户（CA）</h3><p>合约账户有时也叫内部账户，有对应的以太币余额和关联代码，它是由代码控制的，可以通过交易或来自其他合约的调用消息来触发代码执行，执行代码时可以操作自己的存储空间，也可以调用其他合约</p>
<p>合约账户特点总结：</p>
<ol>
<li>拥有以太余额。</li>
<li>有相关的可执行代码（合约代码）。</li>
<li>合约代码能够被交易或者其他合约消息调用。</li>
<li>合约代码被执行时可再调用其他合约代码。</li>
<li>合约代码被执行时可执行复杂运算，可永久地改变合约内部的数据存储。</li>
</ol>
<p>如果大家对概念还理解不深可以先尝试学习后面部分，本教程内容有限，推荐大家有精力阅读以下读物：</p>
<ul>
<li><a href="https://www.zhihu.com/question/61156867" target="_blank" rel="noopener">区块链学习的书籍</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">区块链入门教程</a></li>
<li><a href="https://developer.ibm.com/zh/technologies/blockchain/tutorials/" target="_blank" rel="noopener">IBM教程</a></li>
</ul>
<p><strong>参考自：</strong></p>
<ol>
<li>[比特币白皮书]<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system" target="_blank" rel="noopener">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a>)</li>
<li><a href="https://ethfans.org/posts/ethereum-whitepaper" target="_blank" rel="noopener">以太坊白皮书</a></li>
<li><a href="https://www.chainnode.com/doc/399" target="_blank" rel="noopener">超级账本白皮书</a></li>
<li><a href="https://www.chainnode.com/doc/399" target="_blank" rel="noopener">闪电网络白皮书</a></li>
</ol>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>区块链入门（一）Linux基础</title>
    <url>/posts/cf0a3f0.html</url>
    <content><![CDATA[<h1 id="新手建议"><a href="#新手建议" class="headerlink" title="新手建议"></a>新手建议</h1><h2 id="学习Linux的注意事项"><a href="#学习Linux的注意事项" class="headerlink" title="学习Linux的注意事项"></a>学习Linux的注意事项</h2><ul>
<li><p>Linux严格区分大小写（命令全都是小写）—— 命令、文件名、选项等均区分大小写</p>
</li>
<li><p>Linux中<strong>所有内容</strong>以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件是/dev/sd[a-p]</li>
<li>光盘文件是/dev/sr0等</li>
</ul>
</li>
<li><p>Windows通过扩展名区分文件类型，还有图标可以区分；Linux不靠扩展名区分文件类型，靠文件权限区分，但也有一些约定俗成的扩展名：</p>
<ul>
<li>压缩包：”<em>.gz”, “</em>.bz2”, “<em>.tar.bz2”, “</em>.tgz”等</li>
<li>二进制软件包：”.rpm”</li>
<li>网页文件：”*.sh”</li>
<li>配置文件：”*.conf”</li>
</ul>
<p>注意：这些扩展名不是必要的，即时不加扩展名也没有影响，只是便于管理而已</p>
</li>
<li><p>Linux所有存储设备都必须挂在之后用户才能使用，包括硬盘、U盘、光盘（将设备与挂载点连接的过程就是挂载）</p>
</li>
<li><p>Windows下的程序不能直接在Linux中安装和运行</p>
</li>
</ul>
<h2 id="服务器管理和维护建议"><a href="#服务器管理和维护建议" class="headerlink" title="服务器管理和维护建议"></a>服务器管理和维护建议</h2><h3 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">目录名</th>
<th style="text-align:center">目录作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/bin/</td>
<td style="text-align:center">存放系统命令的目录，普通用户和超级用户都可以执行，不过放在/bin下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td style="text-align:center">/sbin/</td>
<td style="text-align:center">保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td style="text-align:center">/usr/bin/</td>
<td style="text-align:center">存放系统命令的目录，普通用户和超级用户都可以执行，这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td style="text-align:center">/usr/sbin/</td>
<td style="text-align:center">存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用</td>
</tr>
<tr>
<td style="text-align:center">/boot/</td>
<td style="text-align:center">系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td>
</tr>
<tr>
<td style="text-align:center">/dev/</td>
<td style="text-align:center">设备文件保存位置，我们已经说过Linux中所有内容以文件形式保存，包括硬件，这个目录就是用来 保存所有硬件设备的</td>
</tr>
<tr>
<td style="text-align:center">/etc/</td>
<td style="text-align:center">配置文件保存位置，系统内所有采用默认安装方式（npm安装）的服务的配置文件全部保存在这个目录中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等</td>
</tr>
<tr>
<td style="text-align:center">/home/</td>
<td style="text-align:center">每个用户的默认登陆位置，普通用户的home目录就是在/home下建立一个和用户名相同的目录</td>
</tr>
<tr>
<td style="text-align:center">/lib/</td>
<td style="text-align:center">系统调用的函数库保存位置</td>
</tr>
<tr>
<td style="text-align:center">/lost+found/</td>
<td style="text-align:center">当系统意外崩溃或机器意外关机时，产生的一些文件碎片放在这里，当系统启动的过程中fsck工具会对其进行检查，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td style="text-align:center">/media/</td>
<td style="text-align:center">挂载目录，系统建议是用来挂载媒体设备的，例如软盘和光盘</td>
</tr>
<tr>
<td style="text-align:center">/mnt/</td>
<td style="text-align:center">挂载目录，建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td style="text-align:center">/misc/</td>
<td style="text-align:center">挂载目录，系统建议用来挂载NFS服务的共享目录</td>
</tr>
<tr>
<td style="text-align:center">/opt/</td>
<td style="text-align:center">第三方安装的软件保存位置，但现在更多的是保存在/usr/local中</td>
</tr>
<tr>
<td style="text-align:center">/proc/</td>
<td style="text-align:center">虚拟文件系统，该目录的数据不保存到硬盘中，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态灯，如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存 文件系统列表的，/proc/net/是保存网络协议信息的</td>
</tr>
<tr>
<td style="text-align:center">/sys/</td>
<td style="text-align:center">虚拟文件系统，主要保存内核相关信息</td>
</tr>
<tr>
<td style="text-align:center">/root/</td>
<td style="text-align:center">超级用户的家目录</td>
</tr>
<tr>
<td style="text-align:center">/srv/</td>
<td style="text-align:center">服务数据目录， 一些系统服务启动后可以在这个目录保存需要的数据</td>
</tr>
<tr>
<td style="text-align:center">/tmp/</td>
<td style="text-align:center">临时目录，系统存放临时文件的目录，该目录下所有用户都可以访问和写入，我们建议此目录不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td style="text-align:center">/usr/</td>
<td style="text-align:center">系统软件资源目录，注意usr不是user的缩写，而是”Unix Software Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数都在这里</td>
</tr>
<tr>
<td style="text-align:center">/var/</td>
<td style="text-align:center">动态数据保存位置，主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="服务器注意事项"><a href="#服务器注意事项" class="headerlink" title="服务器注意事项"></a>服务器注意事项</h3><ol>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应该关闭服务</li>
<li>不要在服务器的访问高峰运行高负载命令</li>
<li>远程配置防火墙时不要把自己踢出服务器（可以设置每五分钟将防火墙规则重置一次，配置完之后再取消该设置）</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限</li>
<li>定期备份重要数据和日志</li>
</ol>
<p>磁盘分区是用分区编辑器在磁盘上划分几个逻辑部分，碟片一旦划分成数个分区，不同类的目录和文件 可以存储进不同的分区。</p>
<h1 id="系统分区"><a href="#系统分区" class="headerlink" title="系统分区"></a>系统分区</h1><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><ul>
<li>主分区：最多只能有4个</li>
<li>扩展分区：<ul>
<li>最多只能有1个</li>
<li>主分区加扩展分区最多有4个</li>
<li>不能写入数据，只能包含逻辑分区（这种限制是硬盘的限制）</li>
</ul>
</li>
<li>逻辑分区</li>
</ul>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>硬盘经过正确分区后仍不能写入数据，我们的硬盘还必须经过格式化之后才能写入数据。格式化又称逻辑格式化，它是根据用户选定的文件系统（如FAT16、FAT32、NTFS、EXT 2、EXT3、EXT4等），在磁盘的特定区域写入特定数据，在分区中划分出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。格式化就是按照文件系统的规则将硬盘分成等大小的数据块，我们把数据块称为block。</p>
<blockquote>
<p>注：Windows可以识别的系统有FAT16、FAT32、NTFS；Linux可以识别的系统有EXT2、EXT3、EXT4</p>
</blockquote>
<h2 id="设备文件名"><a href="#设备文件名" class="headerlink" title="设备文件名"></a>设备文件名</h2><h4 id="硬盘设备文件名"><a href="#硬盘设备文件名" class="headerlink" title="硬盘设备文件名"></a>硬盘设备文件名</h4><p>Windows是直接分区——&gt;格式化——&gt;分配盘符即可使用，Linux需要分区——&gt;格式化——&gt;给分区建立设备文件名——&gt;分配盘符才能使用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>硬件</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/USB硬盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>光驱</td>
<td>/dev/cdrom或dev/sr0</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[0-1]</td>
</tr>
<tr>
<td>打印机（25针）</td>
<td>/dev/lp[0-2]</td>
</tr>
<tr>
<td>打印机（USB）</td>
<td>/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/mouse</td>
</tr>
</tbody>
</table>
</div>
<h4 id="分区设备文件名"><a href="#分区设备文件名" class="headerlink" title="分区设备文件名"></a>分区设备文件名</h4><p>分区设备文件名直接<strong>在硬盘设备文件名后面加分区号</strong>即可，如</p>
<ul>
<li>IDE硬盘接口第一个分区：/dev/hda1（如今几乎看不到）</li>
<li>SCSI硬盘接口、SATA硬盘接口的第一个分区：/dev/sda1</li>
</ul>
<blockquote>
<p>IDE硬盘是最古老的硬盘，理论最高传输速度是133M/s</p>
<p>SCSI硬盘接口与IDE硬盘同时代，更加昂贵但速度更快，理论最高传输速度可达200M/s，但这种硬盘主要用在服务器上</p>
<p>但上两种硬盘接口如今已经基本淘汰，如今使用更多的是小口的SATA串口硬盘，SATA已发展到3代，其理论传输速度最高可达500M/s，目前不管是服务器还是个人机基本使用的都是SATA硬盘接口。</p>
</blockquote>
<p>需要留意的是，逻辑分区永远都是从5开始的</p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>挂载实际上就是Windows中分配盘符的过程，盘符则被相应地称为挂载点，必须分区的分区有以下两种：</p>
<ol>
<li>根分区：/</li>
<li>swap分区（交换分区）：可以理解为虚拟内存，当真正内存不够用时，可以使用这部分交换分区的硬盘空间来当内存，理论上来说交换分区应该是内存的两倍，但最大不超过2GB</li>
</ol>
<p>若无这两个分区，Linux不能正常使用，但我们还推荐把/boot单独分区，这是为了防止Linux系统启动不起来，一般200MB即可。</p>
<h1 id="远程登陆管理工具"><a href="#远程登陆管理工具" class="headerlink" title="远程登陆管理工具"></a>远程登陆管理工具</h1><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><p>网络连接从虚拟机设置中可以看到，一共有三种：桥接、NAT和Host-only，下面讲解其区别：</p>
<ul>
<li>桥接：桥接意味着虚拟机如同一个单独的主机一样访问Wifi等，也可以和其他机器通信</li>
<li>NAT：虚拟机仅能和主机通信，但若主机可以访问互联网，虚拟机也可以访问互联网</li>
<li>Host-only：虚拟机仅能和主机本机通信，不能访问互联网</li>
</ul>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><ol>
<li>首先调成Host-only模式，使得虚拟机仅与主机连接</li>
<li>在主机上找到VMware Network Adapter VMnet1的IP地址，我本地地址为192.168.19.1</li>
<li>在虚拟机上使用<code>ishw -c netwowrk</code>命令找到logical name，此即为虚拟机的网卡名称，我的虚拟网卡名称为ens33</li>
<li>使用命令ifconfig  [不等于IP地址]  logical name，例如我使用的是<code>ifconfig ens33 192.168.19.2</code></li>
<li>此时再ifconfig即可看到我们设置的已生效</li>
<li>我们可以在主机ping这个IP地址看到生效</li>
<li>使用secureCRT连接即可</li>
</ol>
<p>需要注意的是，以上方法配置IP地址时不是永久生效的，也就是重新启动电脑时就失效了，若想永久生效需要改变配置文件</p>
<p>若使用NAT模式，则步骤简单很多，只需要ifconfig获得IP地址之后直接用secureCRT连接即可</p>
<h2 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h2><p>另外推荐一个Windows主机与Linux虚拟机进行文件传输的工具——WinSCP，操作方法与上面类似，只需输入对应的IP地址即可连接。</p>
<h2 id="安装linux系统（以ubuntu为例）"><a href="#安装linux系统（以ubuntu为例）" class="headerlink" title="安装linux系统（以ubuntu为例）"></a>安装linux系统（以ubuntu为例）</h2><ul>
<li><p>使用vmware虚拟机安装</p>
<p><a href="https://zhuanlan.zhihu.com/p/38797088" target="_blank" rel="noopener">参考此博客：VMware安装Ubuntu18.04</a></p>
</li>
<li><p>使用win10子系统安装</p>
<p><a href="https://zhuanlan.zhihu.com/p/76032647" target="_blank" rel="noopener">参考此博客：在 win10 下使用 ubuntu 子系统</a></p>
</li>
</ul>
<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="一、最常用命令"><a href="#一、最常用命令" class="headerlink" title="一、最常用命令"></a>一、最常用命令</h2><p>这是我们<strong>使用得最多</strong>的命令了，<strong>Linux最基础的命令</strong>！</p>
<ul>
<li>可用 <code>pwd</code>命令查看用户的当前目录</li>
<li>可用 <code>cd</code> 命令来切换目录</li>
<li><code>.</code>表示当前目录</li>
<li><code>..</code> 表示当前目录的上一级目录（父目录）</li>
<li><code>-</code>表示用 cd 命令切换目录<strong>前</strong>所在的目录</li>
<li><code>~</code> 表示<strong>用户主目录</strong>的绝对路径名</li>
</ul>
<p><strong>绝对路径：</strong></p>
<ul>
<li>以斜线（/）开头 ，描述到文件位置的<strong>完整说明</strong> ，任何时候你想指定文件名的时候都可以使用</li>
</ul>
<p><strong>相对路径 ：</strong></p>
<ul>
<li>不以斜线（/）开头 ，指定<strong>相对于你的当前工作目录而言的位置</strong> ，可以被用作指定文件名的简捷方式</li>
</ul>
<h2 id="二、文件处理命令"><a href="#二、文件处理命令" class="headerlink" title="二、文件处理命令"></a>二、文件处理命令</h2><h3 id="1-命令格式与目录处理命令ls"><a href="#1-命令格式与目录处理命令ls" class="headerlink" title="1. 命令格式与目录处理命令ls"></a>1. 命令格式与目录处理命令<code>ls</code></h3><p><strong>命令格式</strong>：<code>命令[-选项][-参数]</code>，例：<code>ls -la /etc</code></p>
<p><strong>说明</strong>：</p>
<ol>
<li>个别命令使用不遵循此格式</li>
<li>当有多个选项时，可以写在一起</li>
<li>简化选项与完整选项：<code>-a</code> 等于 <code>--all</code></li>
</ol>
<p><code>ls</code>命令的语法：</p>
<ol>
<li><p><code>ls -a</code>可以显示所有文件，包括隐藏文件（以点.开头的文件是隐藏文件）</p>
</li>
<li><p>若希望查询的不是当前目录，可以使用<code>ls+其他目录</code>进行查询</p>
</li>
<li><p><code>ls -l</code>可以显示更多属性（long），属性阐述如下：</p>
</li>
<li><p>第一列分为三个部分，第一部分（如d告诉我们文件的类型是一个目录，-为二进制文件，1为软链接文件），drwx表示该文件支持读写和执行操作，r,w,x分别对应读、写、执行三个权限，三列分别对应所有者，所属组，其他人的权限</p>
</li>
<li><p>第二列的2、2、3等表示调用次数</p>
<ol>
<li>第三列表示所有者，也就是这个文件的总负责人（拥有文件的所有权，可转让）</li>
</ol>
</li>
<li>第四列表示所属组，也就是可以操作这个文件的人<ol>
<li>第五列表示文件大小，默认单位是字节（很反Windows）</li>
</ol>
</li>
<li><p>最后一个是文件的最后一次修改时间（Linux没有创建时间这个概念）</p>
</li>
<li><p><code>ls -lh</code>比原先的更人性化（humanitarian），它将对应的单位也显示了出来，<code>-h</code>实际上是一个通用选项，很多命令都可以加</p>
</li>
<li><p><code>-d</code>显示当前目录本身而不显示目录下的数据，一般与<code>-l</code>结合使用，如<code>ls -ld /etc</code></p>
</li>
<li><p><code>ls -id</code>可以查看当前目录对应的文件ID</p>
</li>
</ol>
<h3 id="2-目录处理命令"><a href="#2-目录处理命令" class="headerlink" title="2. 目录处理命令"></a>2. 目录处理命令</h3><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h5><p><strong>语法</strong>：<code>mkdir -p [目录名]</code></p>
<p><strong>功能描述</strong>：创建新目录，<code>-p</code>递归创建（若一个目录本身不存在，可以在创建这个目录的同时创建子目录），也可以同时创建多个目录</p>
<h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a><code>cd</code></h5><p><strong>语法</strong>：<code>cd directory</code></p>
<p><strong>功能描述</strong>：改变当前目录</p>
<h5 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h5><p><strong>语法</strong>：<code>pwd</code></p>
<p><strong>功能描述</strong>：显示当前目录（print working directory）</p>
<h5 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a><code>rmdir</code></h5><p><strong>语法</strong>：<code>rmdir [目录名]</code></p>
<p><strong>功能描述</strong>：删除空目录（若目录非空则不能删除）</p>
<h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h5><p><strong>语法</strong>：<code>cp -rf [源文件或目录] [目标目录] -r 复制目录 -p 保留文件属性（文件创建时间等不发生变化）</code></p>
<p><strong>功能描述</strong>：复制文件或目录</p>
<h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h5><p><strong>语法</strong>：<code>mv [源文件或目录] [目标目录]</code></p>
<p><strong>功能描述</strong>：剪切文件、改名</p>
<h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h5><p><strong>语法</strong>：<code>rm -rf [文件或目录] -r 删除目录 -f 强制执行</code></p>
<p><strong>功能描述</strong>：删除文件</p>
<h3 id="3-文件处理命令"><a href="#3-文件处理命令" class="headerlink" title="3. 文件处理命令"></a>3. 文件处理命令</h3><h5 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h5><p><strong>语法</strong>：<code>touch [文件名]</code></p>
<p><strong>功能描述</strong>：创建空文件</p>
<h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h5><p><strong>语法</strong>：<code>cat [文件名]</code></p>
<p><strong>功能描述</strong>：显示文件内容  <code>-n</code>可显示行号</p>
<h5 id="tac"><a href="#tac" class="headerlink" title="tac"></a><code>tac</code></h5><p>与<code>cat</code>相反，可以倒着显示</p>
<h5 id="more"><a href="#more" class="headerlink" title="more"></a><code>more</code></h5><p><code>cat</code>命令显示的往往过多，若希望分页显示可以使用<code>more</code>，用法与<code>cat</code>相同，使用时按空格可以一页页往后翻，使用q或Q退出</p>
<h5 id="less"><a href="#less" class="headerlink" title="less"></a><code>less</code></h5><p>由于<code>more</code>无法向上翻，我们可以使用<code>less</code>命令，可以使用page up一页页往上翻，也可以使用上箭头一行行往上翻，其他操作与<code>more</code>相同。另外<code>less</code>还可以进行搜索，比如想要搜索关键词service，可以输入/service进行检索，页面会对这些关键词进行高亮，可以使用<code>n</code>找到其他关键词位置</p>
<h5 id="head"><a href="#head" class="headerlink" title="head"></a><code>head</code></h5><p>若只想要看文件的前几行，可以使用<code>head -n</code>加指定行数，若不加则默认显示前10行</p>
<h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a><code>tail</code></h5><p>与<code>head</code>类似 ，但是显示后面几行。</p>
<p>常用搭配为：<code>tail -f</code>，该命令会动态显示文件末尾内容</p>
<h2 id="三、链接命令ln"><a href="#三、链接命令ln" class="headerlink" title="三、链接命令ln"></a>三、链接命令<code>ln</code></h2><p><strong>语法</strong>：<code>ln -s [原文件] [目标文件] -s 创建软链接</code></p>
<p><strong>功能描述</strong>：生成链接文件</p>
<p><strong>示例</strong>：</p>
<ul>
<li><code>ln -s /etc/issue issue.soft</code>：生成软链接</li>
<li><code>ln /etc/issue issue.hard</code>：生成硬链接</li>
</ul>
<p><strong>软链接和硬链接的区别</strong></p>
<p>我们使用<code>ls -l</code>查看这两个文件的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 2 root root 26 Jul 15  2020 issue.hard</span><br><span class="line">lrwxrwxrwx 1 root root 10 Jan 31 04:55 issue.soft -&gt; &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure>
<p>我们会发现这两个文件的信息相差的非常多，软链接文件开头的文件类型是<code>l(link)</code>，三个权限都是<code>rwx</code>，即可读可写可执行，软链接文件就类似于Windows的快捷方式，用处是便于做管理，我们可以看到最后有一个箭头指向<code>/etc/issue</code>。另外我们看到这个文件只有31个字节，因为它只是一个符号链接。我们可以总结得出软链接的三个特点：</p>
<ol>
<li>权限是<code>rwx</code></li>
<li>文件很小，只是符号链接</li>
<li>箭头指向源文件</li>
</ol>
<p>下面我们看硬链接的特点，我们首先分别查看 这两个文件的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l issue.hard</span><br><span class="line">ls -l &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure>
<p>我们可以看到这两个文件的所有信息一模一样，包括文件的大小，这类似于拷贝，似乎相当于<code>cp -p</code>，而硬链接和<code>cp -p</code>的最大不同就是硬链接可以实现同步更新，我们可以做一个简单的实验，我们先查看硬链接文件，然后往源文件中写入文件，可以发现硬链接文件也被同时修改了，当然软链接也会同步修改。</p>
<p>但当我们将源文件复制到另一个位置并删除原位置文件之后，再试图打开软链接会提示“没有那个文件或目录”，而且再显示这个目录软链接会标红并一直闪，而硬链接可以正常访问，没有影响，这就是硬链接和软连接的不同之处。</p>
<p>实际上我们可以通过命令<code>ls -i</code>来识别其<code>i</code>节点以辨别出是硬链接还是软链接，硬链接和源文件的<code>i</code>节点相同，软链接则不同。</p>
<p>硬链接相当于一个同步文件，但可以做实时备份（一个文件删了不会影响另一个文件），硬链接有两个限制，这也是硬链接和软链接的区别：</p>
<ol>
<li>不能跨分区</li>
<li>不能针对目录使用</li>
</ol>
<h2 id="四、权限管理命令"><a href="#四、权限管理命令" class="headerlink" title="四、权限管理命令"></a>四、权限管理命令</h2><p>Linux用户一共分成三类，分别是所有者（U），所属组（G）和其他人（O），权限也分成三类，分别是<code>r</code>，<code>w</code>，<code>x</code>，对应读、写、执行，我们首先学习如何更改权限。</p>
<h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><code>chmod</code></h4><p>更改文件的人只能是文件所有者或者管理员root用户，更改文件权限有两种方式，第一种方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [&#123;ugoa&#125;&#123;+-&#x3D;&#125;&#123;rwx&#125;][文件或目录]</span><br></pre></td></tr></table></figure>
<p>其中第一个花括号里<code>u</code>，<code>g</code>，<code>o</code>，<code>a</code>分别表示所有者，所属组，其他人和所有人，第二个花括号<code>+</code>和<code>-</code>分别表示增加和减少权限，<code>=</code>表示成为后面的权限。第二种方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [mod&#x3D;421][文件或目录] -R 递归修改</span><br></pre></td></tr></table></figure>
<p>数字的意思只是将三个权限位分别用数字来表示，比如<code>r</code>用4表示，<code>w</code>用2表示，<code>x</code>用1表示，则若要表示<code>rwxrw-r--</code>则记为<code>764</code></p>
<h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a><code>chown</code></h4><p>命令英文原意是<code>change file ownership</code>，作用是改变文件或目录的所有者，改变文件file的所有者为user的具体用法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown user file</span><br></pre></td></tr></table></figure>
<p>要注意只有root和文件的所有者可以改变文件的权限</p>
<h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a><code>chgrp</code></h4><p>命令英文原意是<code>change file  group ownership</code>，作用是改变文件或目录的所属组，若具体用法和前面<code>chown</code>相同。我们可以使用<code>groupadd</code>命令添加组（使用<code>useradd</code>命令添加用户）</p>
<h4 id="umask"><a href="#umask" class="headerlink" title="umask"></a><code>umask</code></h4><p>命令英文原意是<code>the user file-creation mask</code>，作用是显示、设置文件的缺省权限，语法是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask [-S]</span><br></pre></td></tr></table></figure>
<p>其中<code>-S</code>的作用是显示新建文件的缺省权限，但需要注意的是缺省创建文件时不可以有可执行权限的，所以当<code>touch</code>创建文件时会发现所有权限都少了<code>x</code>。</p>
<p>当我们直接使用<code>umask</code>时，比如显示0022，第一个0是特殊权限，我们暂时不涉及，第二只第四位分别是所有者、所属组和其他人，我们的最终权限实际上是<code>777-022=755</code>，也就是<code>rwx r-x r-x</code>，当然这指的是目录，如果是文件由于没有可执行权限，文件权限应当是<code>rw- r-- r--</code>，当然缺省创建的权限可以更改，直接使用<code>umask 077</code>即可将文件缺省权限更改为<code>rwx --- ---</code>，但不推荐做这种更改</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL入门（三）条件查询</title>
    <url>/posts/ca70db86.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - MySQL</span><br><span class="line">comments: true</span><br><span class="line">typora-root-url: .</span><br><span class="line">top: 8</span><br></pre></td></tr></table></figure>
<p>本文数据集下载链接：<a href="https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g</a> ，提取码：7gfa </p>
<h1 id="一、条件查询基础"><a href="#一、条件查询基础" class="headerlink" title="一、条件查询基础"></a>一、条件查询基础</h1><p>我们知道从 MySQL 表中使用 SQL<code>SELECT</code> 语句来读取数据，如需有条件地从表中选取数据，可将 <code>WHERE</code> 子句添加到 <code>SELECT</code>语句中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等号，检测两个值是否相等，如果相等返回true</td>
<td style="text-align:left">(A = B) 返回false。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;, !=</td>
<td style="text-align:left">不等于，检测两个值是否相等，如果不相等返回true</td>
<td style="text-align:left">(A != B) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td>
<td style="text-align:left">(A &gt; B) 返回false。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td>
<td style="text-align:left">(A &lt; B) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td>
<td style="text-align:left">(A &gt;= B) 返回false。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td>
<td style="text-align:left">(A &lt;= B) 返回 true。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">				查询列表 </span><br><span class="line">	FROM </span><br><span class="line">				表名 </span><br><span class="line">	WHERE </span><br><span class="line">				筛选条件</span><br></pre></td></tr></table></figure>
<p><strong>分类</strong></p>
<ol>
<li>按条件表达式筛选：&gt; &lt; = != &lt;&gt; &gt;+ &lt;=</li>
<li>按逻辑表达式筛选：&amp;&amp;  ||  !（and or not）</li>
<li>模糊查询：LIKE,  BETWEEN AND, IN, IS NULL</li>
</ol>
<h1 id="二、三种查询方式介绍"><a href="#二、三种查询方式介绍" class="headerlink" title="二、三种查询方式介绍"></a>二、三种查询方式介绍</h1><h2 id="1-按条件表达式筛选"><a href="#1-按条件表达式筛选" class="headerlink" title="1. 按条件表达式筛选"></a>1. 按条件表达式筛选</h2><p><strong>案例一：查询工资&gt;12000的员工信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE salary&gt;12000;</span><br></pre></td></tr></table></figure>
<p><strong>案例二：查询部门编号不等于90号的员工名和部门编号</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, department_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE department_id&lt;&gt;90;</span><br></pre></td></tr></table></figure>
<h2 id="2-按逻辑表达式筛选"><a href="#2-按逻辑表达式筛选" class="headerlink" title="2. 按逻辑表达式筛选"></a>2. 按逻辑表达式筛选</h2><p><strong>案例一：查询工资在10000到20000之间的员工名、工资及奖金</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, salary, commission_pct </span><br><span class="line">FROM employees </span><br><span class="line">WHERE salary&gt;&#x3D;10000 AND salary&lt;&#x3D;20000;</span><br></pre></td></tr></table></figure>
<p><strong>案例二：查询部门编号不是在90到110之间的，或者工资高于15000的员工信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE department_id&lt;90 </span><br><span class="line">OR department_id&gt;110 </span><br><span class="line">OR salary&gt;15000;</span><br></pre></td></tr></table></figure>
<p>更为简洁的写法是（使用逻辑表达式）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE NOT(department_id&gt;&#x3D;90 AND department_id&lt;&#x3D;110) OR salary&gt;15000;</span><br></pre></td></tr></table></figure>
<h2 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3. 模糊查询"></a>3. 模糊查询</h2><h3 id="3-1-LIKE"><a href="#3-1-LIKE" class="headerlink" title="3.1 LIKE"></a>3.1 LIKE</h3><ul>
<li>一般和通配符搭配使用</li>
<li>通配符：<ul>
<li>$\%$ 百分号：任意多个字符，包含0个字符</li>
<li>$_$ 下划线：任意单个字符</li>
</ul>
</li>
</ul>
<p><strong>案例一：查询员工名中包含字符a的员工信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE last_name LIKE &#39;%a%&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>案例二：查询员工名中第三个字符为n，第五个字符为l的员工名和工资</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, salary </span><br><span class="line">FROM employees </span><br><span class="line">WHERE last_name LIKE &#39;__n_l%&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>案例三：查询员工名中第二个字符为下划线（_）的员工名，第二种方法为手动指定转义字符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name </span><br><span class="line">FROM employees </span><br><span class="line">WHERE last_name </span><br><span class="line">LIKE &#39;_\_%&#39;;</span><br></pre></td></tr></table></figure>
<p>第二种方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name </span><br><span class="line">FROM employees </span><br><span class="line">WHERE last_name LIKE &#39;_$_%&#39; ESCAPE &#39;$&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-BETWEEN-AND"><a href="#3-2-BETWEEN-AND" class="headerlink" title="3.2 BETWEEN AND"></a>3.2 BETWEEN AND</h3><ol>
<li><p>使用BETWEEN AND可以提高语句的简洁度</p>
<ol>
<li>包含临界值</li>
<li>两个值不能颠倒顺序</li>
</ol>
</li>
</ol>
<p><strong>案例：查询员工编号在100到120之间的员工信息，第一种做法较繁琐，第二种用BETWEEN AND</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE employee_id&gt;&#x3D;100 </span><br><span class="line">AND employee_id&lt;&#x3D;120;</span><br></pre></td></tr></table></figure>
<p>或者更简洁的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE employee_id BETWEEN 100 AND 120;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-IN"><a href="#3-3-IN" class="headerlink" title="3.3 IN"></a>3.3 IN</h3><ol>
<li>使用IN提高语句简洁度</li>
<li>IN列表的值类型必须一致或兼容</li>
<li>不支持下划线或通配符</li>
</ol>
<p><strong>案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE job_id&#x3D;&#39;IT_PROG&#39; </span><br><span class="line">OR job_id&#x3D;&#39;AD_VP&#39; OR job_id&#x3D;&#39;AD_PRES&#39;;</span><br></pre></td></tr></table></figure>
<p>或者更简洁的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE job_id IN (&#39;IT_PROG&#39;, &#39;AD_VP&#39;, &#39;AD_PRES&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="3-4-IS-NULL"><a href="#3-4-IS-NULL" class="headerlink" title="3.4 IS NULL"></a>3.4 IS NULL</h3><ul>
<li>=或&lt;&gt;不能用于判断null值</li>
<li>is null或is not null可以判断null值</li>
</ul>
<p><strong>案例：查询没有奖金的员工名和奖金率</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, commission_pct </span><br><span class="line">FROM employees </span><br><span class="line">WHERE commission_pct IS NULL;</span><br></pre></td></tr></table></figure>
<p><strong>变式：查询有奖金的员工名和奖金率</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, commission_pct </span><br><span class="line">FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>
<p><strong>注意：以下为错误：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE salary IS 12000;</span><br></pre></td></tr></table></figure>
<h2 id="4-安全等与-lt-gt"><a href="#4-安全等与-lt-gt" class="headerlink" title="4. 安全等与 &lt;=&gt;"></a>4. 安全等与 &lt;=&gt;</h2><ol>
<li>优点：既可以判断NULL值又可以判断普通数值</li>
<li>缺点：可读性较低</li>
</ol>
<p><strong>案例1：查询没有奖金的员工名和奖金率</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, commission_pct </span><br><span class="line">FROM employees </span><br><span class="line">WHERE commission_pct &lt;&#x3D;&gt; NULL;</span><br></pre></td></tr></table></figure>
<p><strong>案例2：查询工资为12000的员工信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, commission_pct </span><br><span class="line">FROM employees </span><br><span class="line">WHERE salary &lt;&#x3D;&gt; 12000;</span><br></pre></td></tr></table></figure>
<h1 id="三、易混辨析"><a href="#三、易混辨析" class="headerlink" title="三、易混辨析"></a>三、易混辨析</h1><p><strong>where：</strong>数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p>
<p><strong>group by:</strong>对select查询出来的结果集按照某个字段或者表达式进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p>
<p><strong>having：</strong>用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p>
<p><strong>执行顺序</strong></p>
<p><code>select –&gt;where –&gt; group by–&gt; having–&gt;order by</code></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL入门（一）数据库基础概念</title>
    <url>/posts/e89e7d68.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - MySQL</span><br><span class="line">comments: true</span><br><span class="line">typora-root-url: .</span><br><span class="line">top: 6</span><br></pre></td></tr></table></figure>
<h1 id="一、数据库基本概念"><a href="#一、数据库基本概念" class="headerlink" title="一、数据库基本概念"></a>一、数据库基本概念</h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p>
<p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。<strong>数据库的好处</strong>是可以持久化数据到本地，同时可以实现结构化查询，方便管理<strong>数据库相关概念</strong>如下：</p>
<ol>
<li>DB：数据库，保存一组有组织的数据的容器</li>
<li>DBMS：数据库管理系统，又称为数据库软件（产品），用于管理数据库中的数据</li>
<li>SQL：结构化查询语言，用于和DBMS通信的语言</li>
</ol>
<h2 id="1-RDBMS-术语"><a href="#1-RDBMS-术语" class="headerlink" title="1. RDBMS 术语"></a>1. RDBMS 术语</h2><p>在我们开始学习MySQL 数据库前，让我们先了解下RDBMS的一些术语：</p>
<ul>
<li><strong>数据库:</strong> 数据库是一些关联表的集合。</li>
<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li>
<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li><strong>外键：</strong>外键用于关联两个表。</li>
<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ul>
<h2 id="2-MySQL数据库基本概况"><a href="#2-MySQL数据库基本概况" class="headerlink" title="2. MySQL数据库基本概况"></a>2. MySQL数据库基本概况</h2><p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<ul>
<li>MySQL 是开源的，目前隶属于 Oracle 旗下产品。</li>
<li>MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL 使用标准的 SQL 数据语言形式。</li>
<li>MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。</li>
<li>MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。</li>
<li>MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。</li>
<li>MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。</li>
</ul>
<h2 id="4-数据库存储数据的特点"><a href="#4-数据库存储数据的特点" class="headerlink" title="4. 数据库存储数据的特点"></a>4. 数据库存储数据的特点</h2><ol>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个名字用来标识自己，表名具有唯一性</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的“类”的设计</li>
<li>表由列组成，我们也称之为字段。所有表都是由一个或多个列组成的，每一列类似java中的”属性“</li>
<li>表中的数据是按行存储的，每一行类似java中的“对象”</li>
</ol>
<h1 id="二、MySQL基本操作"><a href="#二、MySQL基本操作" class="headerlink" title="二、MySQL基本操作"></a>二、MySQL基本操作</h1><p><strong>MySQL服务的启动和终止</strong></p>
<p>假设已经 安装好了MySQL，我们可以通过Windows中的服务手动 启动或关闭MySQL服务，也可以通过管理员模式打开命令行，使用<code>net stop mysql</code>与<code>net start mysql</code>分别关闭和启动MySQL，</p>
<p><strong>MySQL服务端的登陆和退出</strong></p>
<p>MySQL服务端可以直接通过MySQL Shell进入，但这种方式<strong>只能容许root用户进入</strong>，我们推荐使用命令行进入，在命令行下输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3307 -u root -p</span><br></pre></td></tr></table></figure>
<p>其中3307为本机设定的端口号，每个人可能不一样，-p之后将会要去输入密码，此时输入之前预设的密码即可，也可以直接在后面接，但注意-p若后面直接接密码，<strong>不加空格</strong>。若是直接本机进入，可以省略<code>-h localhost -P 3307</code>。</p>
<p>退出时直接使用<code>exit</code>或<code>Ctrl+C</code>即可</p>
<h1 id="三、MySQL常用命令"><a href="#三、MySQL常用命令" class="headerlink" title="三、MySQL常用命令"></a>三、MySQL常用命令</h1><p>以下命令结尾都需要加分号；</p>
<ul>
<li><p><code>show databases;</code>可以显示所有数据库</p>
</li>
<li><p><code>use+库名</code>：打开某个数据库</p>
</li>
<li><p><code>show tables</code>：显示库中的某个表内容</p>
</li>
<li><p><code>show tables from+库名（比如MySQL）</code>：从某个库显示表</p>
</li>
<li><p><code>select database()</code>：显示所在的库</p>
</li>
<li><p>创建表名为stuinfo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stuinfo(                                                                                   -&gt; id int,                                                                                              -&gt; name varchar(20));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>select * from stuinfo</code>：由于为空表，故返回Empty Set</p>
</li>
<li><p><code>desc stuinfo</code>：显示stuinfo表</p>
</li>
<li><p><code>insert info stuinfo(id,name) values(1, &#39;rose&#39;)</code>：插入表</p>
<p>此时再显示，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from stuinfo;                                                                                 +------+------+                                                                                         | id   | name |                                                                                         +------+------+                                                                                         |    1 | rose |                                                                                         |    2 | john |                                                                                          +------+------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>update stuinfo set name=&#39;lilei&#39; where id=1;</code>将rose的名字修改为lilei</p>
</li>
<li><code>delete from stuinfo where id=1</code>：将lilei删除</li>
<li><code>select version()</code>：显示版本号（也可以退出之后<code>mysql --version</code>查看）</li>
</ul>
<h1 id="四、MySQL的语法规范"><a href="#四、MySQL的语法规范" class="headerlink" title="四、MySQL的语法规范"></a>四、MySQL的语法规范</h1><ol>
<li>不区分大小写，但建议关键字大写，表名、列名小写</li>
<li>每条命令最好分号结尾</li>
<li>每条命令根据需要，可以进行缩进或换行</li>
<li>注释：<ul>
<li>单行注释：#注释文字</li>
<li>单行注释：— 注释文字（需要加空格）</li>
<li>多行注释：/<em> 注释文字 </em>/</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL入门（四）排序查询</title>
    <url>/posts/6b667049.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - MySQL</span><br><span class="line">comments: true</span><br><span class="line">typora-root-url: .</span><br><span class="line">top: 9</span><br></pre></td></tr></table></figure>
<p>本文数据集下载链接：<a href="https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g</a> ，提取码：7gfa </p>
<h1 id="一、排序查询"><a href="#一、排序查询" class="headerlink" title="一、排序查询"></a>一、排序查询</h1><p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据，如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 <strong>ORDER BY</strong> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p>
<h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表</span><br><span class="line">[WHERE 筛选条件]</span><br><span class="line">ORDER BY 排序列表 【ASC】</span><br></pre></td></tr></table></figure>
<p>一般ORDER BY语句放在查询语句的最后【<code>LIMIT</code>子句除外】</p>
<ul>
<li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li>
<li>你可以设定多个字段来排序。</li>
<li>你可以使用 <code>ASC</code> 或 <code>DESC</code> 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li>
<li>你可以添加 <code>WHERE...LIKE</code> 子句来设置条件。</li>
</ul>
<h2 id="2-案例"><a href="#2-案例" class="headerlink" title="2. 案例"></a>2. 案例</h2><p><strong>案例1</strong>：<strong>查询员工信息，要求工资从高到低排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>
<p><strong>查询员工信息，要求工资从低到高排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">ORDER BY salary ASC;</span><br></pre></td></tr></table></figure>
<p><strong>案例2：查询部门编号&gt;=90的员工信息，按入职时间的先后进行排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE department_id &gt;&#x3D; 90 </span><br><span class="line">ORDER BY hiredate ASC;</span><br></pre></td></tr></table></figure>
<p><strong>案例3：按年薪高低显示员工的信息和年薪【按表达式排序】</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *, salary*12*(1+IFNULL(commission_pct,0)) 年薪 </span><br><span class="line">FROM employees </span><br><span class="line">ORDER BY 年薪</span><br></pre></td></tr></table></figure>
<p><strong>案例4：按姓名长度显示员工的姓名和工资【按函数排序】</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(last_name) 字节长度,last_name,salary </span><br><span class="line">FROM employees </span><br><span class="line">ORDER BY 字节长度 DESC;</span><br></pre></td></tr></table></figure>
<p><strong>案例5：查询员工信息，要求先按工资排序，再按员工编号排序【按多个字段排序】</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">ORDER BY salary ASC, employee_id DESC;</span><br></pre></td></tr></table></figure>
<h1 id="二、MySQL拼音排序"><a href="#二、MySQL拼音排序" class="headerlink" title="二、MySQL拼音排序"></a>二、MySQL拼音排序</h1><p>如果字符集采用的是 gbk(汉字编码字符集)，直接在查询语句后边添加 <code>ORDER BY</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM runoob_tbl</span><br><span class="line">ORDER BY runoob_title;</span><br></pre></td></tr></table></figure>
<p>如果字符集采用的是 utf8(万国码)，需要先对字段进行转码然后排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM runoob_tbl</span><br><span class="line">ORDER BY CONVERT(runoob_title using gbk);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>MySQL入门（二）基础查询</title>
    <url>/posts/8bec0637.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - MySQL</span><br><span class="line">comments: true</span><br><span class="line">typora-root-url: .</span><br><span class="line">top: 7</span><br></pre></td></tr></table></figure>
<p>本文数据集下载链接：<a href="https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g</a> ，提取码：7gfa </p>
<p><strong>DQL指的是Data Query Language，即数据查询语言，是MySQL语言中的一个子集</strong></p>
<h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><p>MySQL 数据库使用SQL SELECT语句来查询数据。你可以通过 mysql&gt; 命令提示窗口中在数据库中查询数据，或者通过PHP脚本来查询数据。</p>
<ul>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li>
<li>SELECT 命令可以读取一条或者多条记录。</li>
<li>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li>
<li>你可以使用 WHERE 语句来包含任何条件。</li>
<li>你可以使用 LIMIT 属性来设定返回的记录数。</li>
<li>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li><code>select</code> 查询列表 <code>from</code> 表名;</li>
<li>可以使用 <code>字段</code>区分关键字</li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code> 1. 查询列表可以是：表中的字段、常量、表达式、函数
 2. 查询的结果是一个虚拟的表格
</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>查询表中的单个字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>查询表中的多个字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, salary, email FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>查询表中的所有字段（可以通过全选复制字段名快速复制）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,	first_name,	last_name	email,	phone_number,	job_id,	salary,	commission_pct,	manager_id,	department_id,	hiredate FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>等同于下面语句（但*使得顺序与原来一样）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>查询常量值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100；</span><br><span class="line">SELECT &#39;john&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>查询表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98;</span><br></pre></td></tr></table></figure>
<p><strong>查询函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>
<h1 id="为字段取别名"><a href="#为字段取别名" class="headerlink" title="为字段取别名"></a>为字段取别名</h1><pre><code> 1. 便于理解
 2. 如果要查询的字段有重名的情况，使用别名可以区分开
</code></pre><p><strong>方式一：使用As</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line"></span><br><span class="line">SELECT last_name AS 姓, first_name As 名 </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>方式二：使用空格</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name 姓, first_name 名 </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>案例：查询salary，显示结果为out put</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary AS &#39;out put&#39; </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><p>去重的关键字是<code>DISTINCT</code>，注意：不可以同时对多个字段去重</p>
<p><strong>案例：查询员工表中涉及到的所有的部门编号(DISTINCT关键字)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h1 id="加号和CONCAT的作用"><a href="#加号和CONCAT的作用" class="headerlink" title="加号和CONCAT的作用"></a>加号和CONCAT的作用</h1><p>JAVA中的加号有两个功能：</p>
<pre><code>1. 运算符，两个操作数都是数值型
2. 连接符，只要有一个操作数为字符串
</code></pre><p>MySQL中的加号只有一个功能：运算符</p>
<pre><code>1. 若两个操作数都为数值型，则做加法运算： select 100 + 90;
2. 若其中一方为字符型，试图将字符型数值转换成数值型：select &#39;123&#39;+90;
3. 若转换失败，则将字符型数值转换成0：select &#39;john&#39;+90;
4. 只要有其中一方为null，则结果必为null
</code></pre><p><strong>案例：查询员工名和姓连接成一个字段，并显示为姓名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(last_name,&#39; &#39;,first_name) AS 姓名 </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>案例：显示出表employees的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">		CONCAT(employee_id, &#39;,&#39;,	first_name, &#39;,&#39;,	last_name, &#39;,&#39;,	email, &#39;,&#39;,	phone_number, &#39;,&#39;,	job_id, &#39;,&#39;,	salary, &#39;,&#39;,	IFNULL(commission_pct,0), &#39;,&#39;,	manager_id, &#39;,&#39;,	department_id, &#39;,&#39;,	hiredate)</span><br><span class="line">AS </span><br><span class="line">		out_put </span><br><span class="line">FROM </span><br><span class="line">		employees;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL入门（五）函数</title>
    <url>/posts/a5e4959e.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - MySQL</span><br><span class="line">comments: true</span><br><span class="line">typora-root-url: .</span><br><span class="line">top: 10</span><br></pre></td></tr></table></figure>
<p>本文数据集下载链接：<a href="https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g</a> ，提取码：7gfa </p>
<h1 id="一、常见函数"><a href="#一、常见函数" class="headerlink" title="一、常见函数"></a>一、常见函数</h1><p><strong>调用方法</strong>：<code>SELECT 函数名(实参列表) [FROM 表]</code></p>
<p><strong>优点</strong>：隐藏实现细节；提高代码的重用性</p>
<p><strong>分类</strong>：</p>
<ol>
<li>单行函数，如<code>concat</code>、<code>length</code>、<code>ifnull</code></li>
<li>分组函数，传递一组值进去，传出一个值（又称统计函数）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();		# 查看当前DATABASE</span><br><span class="line">SELECT USER();</span><br><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>
<h1 id="二、单行函数"><a href="#二、单行函数" class="headerlink" title="二、单行函数"></a>二、单行函数</h1><h2 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1. 字符函数"></a>1. 字符函数</h2><p><strong>函数1：<code>LENGTH</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&quot;MySQL&quot;);</span><br><span class="line">SELECT LENGTH(&quot;MySQL真简单&quot;);</span><br></pre></td></tr></table></figure>
<p>第一个显示为5，第二个显示为14（一个汉字占3个字节），由此我们知道<code>LENGTH</code>函数是用于获取参数值的字节个数的</p>
<p><strong>函数2：<code>CONCAT</code>拼接函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(last_name, &#39;_&#39;, first_name) 姓名 FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>函数3：<code>UPPER、LOWER</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&#39;MySQL&#39;);</span><br><span class="line">SELECT LOWER(&#39;MySQL&#39;);</span><br></pre></td></tr></table></figure>
<p><strong>套娃1：将姓大写，名小写然后拼接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(UPPER(last_name),LOWER(first_name)) FROM employees;</span><br></pre></td></tr></table></figure>
<p>由此可见函数可以嵌套调用</p>
<p><strong>函数4：<code>SUBSTR\SUBSTRING</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUBSTR(&#39;我喜欢MySQL&#39;, 4) output;</span><br></pre></td></tr></table></figure>
<p>该函数返回<code>MySQL</code>，由此我们可见该函数的作用是返回索引及其之后的内容，同时我们可以发现MySQL中的<strong>索引是从0开始</strong>的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUBSTR(&#39;我喜欢你&#39;, 2, 4) output;</span><br></pre></td></tr></table></figure>
<p>该函数返回<code>喜欢你</code>，这里是截取从指定索引处指定字符长度的字符</p>
<p><strong>套娃2：姓名中首字符大写，其他字符小写，并用_拼接显示出来</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)),&#39;_&#39;,LOWER(SUBSTR(last_name, 2))) output FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>函数5：<code>instr</code>返回起始索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&#39;我喜欢MySQL&#39;, &#39;MySQL&#39;) AS output;</span><br></pre></td></tr></table></figure>
<p>返回结果为4</p>
<p>注意：如果找不到对应索引，返回0</p>
<p><strong>函数6：<code>trim</code>去首尾空格</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">SELECT TRIM(<span class="string">'    MySQL   '</span>) AS output;</span><br></pre></td></tr></table></figure>
<p>实际上也可以去除前后某个指定的元素，比如我们要去除下例中首尾的<code>a</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRIM(&#39;a&#39; FROM &#39;aaaaaaaMySQLaaaa&#39;) AS output;</span><br></pre></td></tr></table></figure>
<p><strong>函数7：<code>lpad</code>用指定字符实现左填充指定长度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&#39;MySQL&#39;, 10, &#39;*&#39;) AS output;</span><br></pre></td></tr></table></figure>
<p>返回结果为<code>*****MySQL</code>，若我们将长度指定为小于字段长的数字，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&#39;MySQL&#39;, 3, &#39;*&#39;) AS output;</span><br></pre></td></tr></table></figure>
<p>返回值为<code>MyS</code></p>
<p><strong>函数8：<code>rpad</code>用指定字符右填充指定长度</strong></p>
<p>用法与左填充一样</p>
<p><strong>函数9：<code>replace</code>替换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&#39;我爱MySQL&#39;, &#39;爱&#39;, &#39;讨厌&#39;) AS output;</span><br></pre></td></tr></table></figure>
<p>结果很容易猜到，嘿嘿这里就不说啦。而且注意哦，这里的替换是全部替换，可以自己验证一下</p>
<h2 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2. 数学函数"></a>2. 数学函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">round: 四舍五入</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT ROUND(-1.55);		# 输出结果为-2</span><br><span class="line">SELECT ROUND(1.467,2);		# 输出结果为1.47</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">ceil: 向上取整(返回大于等于该数的最小整数)</span><br><span class="line">floor: 向下取整(返回小于等于该数的最大整数)</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT CEIL(1.01);			# 输出结果为2</span><br><span class="line">SELECT FLOOR(-9.99);		# 输出结果为-10</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">truncate: 截断</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT TRUNCATE(1.65, 1);	# 输出结果为1.6</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">mod: 取余</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT MOD(10, 3);			# 输出结果为1</span><br><span class="line"># 被除数如果是正则为正，如果是负则为负，因为运算方式为：MOD(a,b)&#x3D;a-a&#x2F;b*b</span><br></pre></td></tr></table></figure>
<h2 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h2><h3 id="3-1-获取日期的函数"><a href="#3-1-获取日期的函数" class="headerlink" title="3.1 获取日期的函数"></a>3.1 获取日期的函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># now: 返回当前系统日期+时间</span><br><span class="line">SELECT NOW();</span><br><span class="line"></span><br><span class="line"># curdate: 返回当前系统日期，不包含时间</span><br><span class="line">SELECT CURDATE();</span><br><span class="line"></span><br><span class="line"># curtime: 返回当前系统时间，不包含日期</span><br><span class="line">SELECT CURTIME();</span><br><span class="line"></span><br><span class="line"># 也可以自己定其他截取的时间特征:</span><br><span class="line">SELECT YEAR(NOW()); 		# 返回今年</span><br><span class="line"># 若希望返回英文：</span><br><span class="line">SELECT MONTHNAME(NOW());</span><br></pre></td></tr></table></figure>
<h3 id="3-2-转换日期的函数"><a href="#3-2-转换日期的函数" class="headerlink" title="3.2 转换日期的函数"></a>3.2 转换日期的函数</h3><p><strong><code>STR_TO_DATE</code></strong></p>
<p>该函数的作用是按日期格式的字符转换成指定格式的日期，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&#39;1999&#x2F;2&#x2F;18&#39;,&#39;%Y&#x2F;%m&#x2F;%d&#39;);</span><br></pre></td></tr></table></figure>
<p>返回<code>1999-02-18</code>，小伙伴可以自己尝试大小写的区别，并自行查阅其他格式符的含义和功能</p>
<p><strong><code>DATE_FORMAT</code></strong></p>
<p>该函数的作用是将日期转换成字符，恰好与<code>STR_TO_DATE</code>反过来，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%Y年%m月%d日&#39;);</span><br></pre></td></tr></table></figure>
<p><strong>案例1：查询入职日期是1992年4月3号的员工信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees </span><br><span class="line">WHERE hiredate &#x3D; STR_TO_DATE(&#39;1992年4月3日&#39;,&#39;%Y年%m月%d日&#39;);</span><br></pre></td></tr></table></figure>
<p><strong>案例2：查询有奖金的员工名及入职日期，要求格式为：xx月/xx日/xx年</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, DATE_FORMAT(hiredate,&#39;%m月&#x2F;%d日 %y年&#39;) 入职日期 </span><br><span class="line">FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>
<h1 id="三、流程控制函数"><a href="#三、流程控制函数" class="headerlink" title="三、流程控制函数"></a>三、流程控制函数</h1><h2 id="1-IF函数"><a href="#1-IF函数" class="headerlink" title="1. IF函数"></a>1. <code>IF</code>函数</h2><p><code>IF</code>函数有三个参数，第一个表达式的结果若为 true，则返回表达式二的值，否则返回表达式三的值，如下将返回21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&gt;5, 21, 10);</span><br></pre></td></tr></table></figure>
<p><strong>示例：若员工有奖金则提示有，否则提示没有</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, commission_pct, IF(commission_pct IS NULL, &#39;没奖金&#39;, &#39;有奖金&#39;) FROM employees;</span><br></pre></td></tr></table></figure>
<h2 id="2-case函数"><a href="#2-case函数" class="headerlink" title="2. case函数"></a>2. <code>case</code>函数</h2><p><strong>使用语法一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE 要判断的字段或表达式</span><br><span class="line">WHEN 常量1  THEN  要显示的值1或语句1</span><br><span class="line">WHEN 常量2  THEN  要显示的值2或语句2</span><br><span class="line">...</span><br><span class="line">ELSE 要显示的值n或语句n</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><strong>案例1：查询员工的工资，要求部门编号=30，则显示工资为1.1倍，部门编号=20，则显示工资为1.2倍，部门编号=30，则显示工资为1.3倍，其他部门显示的工资为原工资</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary 原始工资, department_id, </span><br><span class="line">CASE department_id </span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary;</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p><strong>使用语法二：类似于多重<code>if</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">WHEN 条件1 THEN 要显示的值1或语句1</span><br><span class="line">WHEN 条件2 THEN 要显示的值2或语句2</span><br><span class="line">...</span><br><span class="line">THEN 要显示的值n或语句n</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><strong>案例2:查询员工的工资情况：如果工资&gt;20000，显示级别A，若工资&gt;15000，显示级别B，若工资&gt;10000，显示级别C，否则显示级别D </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary,</span><br><span class="line">CASE</span><br><span class="line">WHEN salary&gt;20000 THEN &#39;A&#39;</span><br><span class="line">WHEN salary&gt;15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary&gt;10000 THEN &#39;C&#39;</span><br><span class="line">ELSE &#39;D&#39;</span><br><span class="line">END AS &#39;工资级别&#39;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL入门（六）分组查询</title>
    <url>/posts/ceaf7866.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - MySQL</span><br><span class="line">comments: true</span><br><span class="line">typora-root-url: .</span><br><span class="line">top: 11</span><br></pre></td></tr></table></figure>
<p>本文数据集下载链接：<a href="https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g" target="_blank" rel="noopener">https://pan.baidu.com/s/1sVcSXfVZimc6ruyMr4Gr3g</a> ，提取码：7gfa </p>
<h1 id="一、分组函数简介"><a href="#一、分组函数简介" class="headerlink" title="一、分组函数简介"></a>一、分组函数简介</h1><p><code>GROUP BY</code> 语句根据一个或多个列对结果集进行分组，在分组的列上我们可以使用 <code>COUNT, SUM, AVG</code>等函数。</p>
<p><strong>功能</strong>：用于统计，又称为聚合函数或统计函数或组函数</p>
<p><strong>分类</strong>：<code>sum</code>求和，<code>avg</code>平均值，<code>max</code>最大值，<code>min</code>最小值，<code>count</code>计算个数</p>
<p><strong>特点</strong>：</p>
<ol>
<li><code>SUM, AVG</code>一般处理数值型， <code>MAX, MIN, COUNT</code>可以处理任何类型</li>
<li>是否忽略<code>NULL</code>值：所有分组函数都忽略<code>NULL</code>值</li>
<li>可以和<code>DISTINCT</code>搭配实现去重运算</li>
<li><code>COUNT</code>函数的专门介绍</li>
</ol>
<h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">SELECT COUNT(salary) FROM employees; </span><br><span class="line">SELECT SUM(salary) 和, ROUND(AVG(salary), 2) 平均, MAX(salary) 最高, MIN(salary) 最低, COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure>
<h2 id="2-参数类型"><a href="#2-参数类型" class="headerlink" title="2. 参数类型"></a>2. 参数类型</h2><p>以下为无意义但不报错的使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(last_name), AVG(last_name) </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>同理还有对日期求和等，也是无意义的。以下使用方式是合理的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(last_name), MIN(last_name) </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>这是因为可以按照首字母排序，于是也有最大值和最小值，同理对日期求最大最小值也是可以的</p>
<p>也可以使用<code>COUNT</code>语句对其他类型求和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(commission_pct), COUNT(last_name) </span><br><span class="line">FROM employees;</span><br><span class="line"># 返回35和107</span><br></pre></td></tr></table></figure>
<p>两者不同是因为<code>COUNT</code>返回 不为NULL的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(DISTINCT salary), sum(salary) </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<h2 id="3-COUNT函数详解"><a href="#3-COUNT函数详解" class="headerlink" title="3. COUNT函数详解"></a>3. <code>COUNT</code>函数详解</h2><p><strong>统计总行数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>每一行中只要有不为<code>NULL</code>的计数器就加一，同理也可以使用以下方式统计总行数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(1) </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>事实上，<code>COUNT()</code>中的常量值可以取任何值获得同样的效果，但就效率而言</p>
<ul>
<li>在MYISAM存储引擎下，<code>COUNT(*)</code>的效率高</li>
<li>在INNODB存储引擎下，<code>COUNT(*)</code>的效率和<code>COUNT(1)</code>差不多，但比<code>COUNT(字段)</code>效率高</li>
</ul>
<p>因此一般使用<code>COUNT(*)</code>来统计行数</p>
<p><strong>注意：和分组函数一同查询的字段有限制(要求是group by后的字段)</strong></p>
<h1 id="二、分组查询"><a href="#二、分组查询" class="headerlink" title="二、分组查询"></a>二、分组查询</h1><ol>
<li><p>筛选条件可分为两类：分组前筛选和分组后筛选</p>
<p>|                | <strong>数据源</strong>     | <strong>位置</strong>             | <strong>关键字</strong> |<br>| ——————— | ——————— | —————————— | ————— |<br>| <strong>分组前筛选</strong> | 原始表         | <code>GROUP BY</code>子句的前面 | <code>WHERE</code>    |<br>| <strong>分组后筛选</strong> | 分组后的结果集 | <code>GROUP BY</code>子句的后面 | <code>HAVING</code>   |</p>
</li>
<li><p><code>GROUP BY</code>子句支持单个字段分组、多个字段分组（多个字段之间用逗号隔开，没有顺序要求）</p>
</li>
<li><p>也可以添加排序（放在整个分组查询最后）</p>
</li>
</ol>
<p>注：</p>
<ol>
<li>分组函数做条件肯定是放在HAVING子句中</li>
<li>能用分组前筛选的优先使用分组前筛选</li>
</ol>
<h2 id="1-GROUP-BY语法"><a href="#1-GROUP-BY语法" class="headerlink" title="1. GROUP BY语法"></a>1. <code>GROUP BY</code>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure>
<h2 id="2-具体示例"><a href="#2-具体示例" class="headerlink" title="2. 具体示例"></a>2. 具体示例</h2><p><strong>查询每个部门的平均工资</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT department_id, AVG(salary) </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure>
<p><strong>查询每个工种有奖金的员工的最高工资</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary), job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure>
<p><strong>根据上一题查询结果筛选最高工资&gt;12000</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary), job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">GROUP BY job_id </span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br></pre></td></tr></table></figure>
<p><strong>查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary), manager_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE manager_id&gt;102</span><br><span class="line">GROUP BY manager_id </span><br><span class="line">HAVING MIN(salary)&gt;5000</span><br></pre></td></tr></table></figure>
<p><strong>按表达式（函数）分组：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些</strong></p>
<p>① 查询每个长度的员工个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*), LENGTH(last_name) len_name </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY LENGTH(last_name);</span><br></pre></td></tr></table></figure>
<p>② 添加筛选条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*), LENGTH(last_name) len_name </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY LENGTH(last_name) </span><br><span class="line">HAVING COUNT(*) &gt; 5;</span><br></pre></td></tr></table></figure>
<p><strong>按多个字段分组</strong></p>
<p>案例：查询每个部门每个工种的员工的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary), department_id, job_id </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department_id, job_id;</span><br></pre></td></tr></table></figure>
<p><strong>添加排序</strong></p>
<p>案例：查询部门编号不为NULL的每个工种的员工的平均工资，并按工资高低显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary), department_id, job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE department_id IS NOT NULL </span><br><span class="line">GROUP BY department_id, job_id </span><br><span class="line">ORDER BY AVG(salary) DESC;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
