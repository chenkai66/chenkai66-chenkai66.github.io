<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    区块链入门（二）基础知识介绍 |  言念君子
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-区块链入门（二）基础知识介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  区块链入门（二）基础知识介绍
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/fb46f828.html" class="article-date">
  <time datetime="2021-04-05T13:35:24.042Z" itemprop="datePublished">2021-04-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Blockchain/">Blockchain</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">39 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <font color="red"> 注：本教程为技术教程，不谈论且不涉及炒作任何数字货币 </font>

<p>本次组队学习重点在于以太坊基础知识、以太坊客户端以及以太坊solidity编程，因此本节教程重点在于以太坊核心知识点的掌握，区块链部分的基础知识可以作为补充，请学习者量力而行。另外若学习者觉得本节内容难度太高，可以先对基本知识点有一个概览，在第二节以及第三节实战内容学习完成之后再深入学习本节内容。</p>
<h1 id="一、区块链简介"><a href="#一、区块链简介" class="headerlink" title="一、区块链简介"></a>一、区块链简介</h1><h2 id="1-1、区块链与区块链技术"><a href="#1-1、区块链与区块链技术" class="headerlink" title="1.1、区块链与区块链技术"></a>1.1、区块链与区块链技术</h2><p>在阅读本教程之前，<a href="http://blog.codinglabs.org/articles/bitcoin-mechanism-make-easy.html" target="_blank" rel="noopener">大家对比特币原理不太了解同学可以先阅读下此博客~</a>,大家对比特币有简单了解后对于区块链会有更好的认识。</p>
<p><strong>区块链</strong>是将记录（区块）通过密码学串联并加密的链式数据结构。而<strong>区块链技术</strong>，是通过P2P网络和区块链来实现数据存储的<strong>去中心化</strong>、<strong>不可逆</strong>和<strong>不可篡改</strong>。比特币正是构建在区块链技术上的典型应用。通过区块链技术，我们可以将信息（数据、程序）保存在区块上并接入到区块链中，这样就实现了信息的去中心化存储、不可逆和不可篡改。<strong>区块链应用</strong>是指利用区块链技术开发的应用。</p>
<h2 id="1-2、区块链历史"><a href="#1-2、区块链历史" class="headerlink" title="1.2、区块链历史"></a>1.2、区块链历史</h2><p>2008年，一个网名叫中本聪（Satoshi Nakamoto）的人发表了一篇名为《比特币：一种点对点电子货币系统》的论文，论文中首次提到了“区块链”这一概念。2009年，中本聪创立了以区块链为底层技术的比特币网络，开发出了第一个区块，被称为“创世区块”。该阶段被称为“区块链1.0”。</p>
<p>由于比特币是一个电子货币系统，所以主要功能就是记账。但随后人们发现，区块链技术作为比特币的底层技术，功能可以远远不止于记账，许多关于“未知的信任”的问题，都可以通过区块链来解决，例如电子存证、信息记录等。于是在比特币的基础上，诞生了带有智能合约的区块链系统，即允许开发者通过编写智能合约来实现特定的逻辑，这一阶段被称为“区块链2.0”。这一阶段的主要代表是以太坊。</p>
<p>随后，人们想要提升区块链应用的性能，于是出现了EOS、ArcBlock等系统，其特点是高性能、大吞吐量，但由于引入了超级节点、云节点等特性，弱化了“去中心化”这一特点，因此受到较大的争议。这一阶段被称为“区块链3.0”。</p>
<p>由于比特币是一款电子货币，可扩展性较低，而所谓的“区块链3.0”目前受到较大争议，且部分项目的底层算法完全不同于典型的区块链，因此学习区块链2.0中的以太坊是目前学习区块链的最佳方式。</p>
<h2 id="1-3、区块链基础技术与算法"><a href="#1-3、区块链基础技术与算法" class="headerlink" title="1.3、区块链基础技术与算法"></a>1.3、区块链基础技术与算法</h2><p>区块链技术不是单独的一项技术，而是一系列技术组成的技术栈，其具有以下的特点：</p>
<ul>
<li>数据分布式存储</li>
<li>存储的数据不可逆、不可篡改、可回溯</li>
<li>数据的创建和维护由所有参与方共同参与</li>
</ul>
<p>为了实现这些特点、维护区块链应用的稳定运行，区块链技术中包含了分布式存储技术、密码学技术、共识机制以及区块链2.0提出的智能合约。</p>
<h3 id="1-3-1、区块"><a href="#1-3-1、区块" class="headerlink" title="1.3.1、区块"></a>1.3.1、区块</h3><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\bg2017122703.png" width="300">
</center>
<center>中心化存储</center>

<p>每个区块包含两个部分。</p>
<blockquote>
<ul>
<li>区块头（Head）：记录当前区块的特征值</li>
<li>区块体（Body）：实际数据</li>
</ul>
</blockquote>
<p>区块头包含了当前区块的多项特征值。</p>
<blockquote>
<ul>
<li>生成时间</li>
<li>实际数据（即区块体）的哈希</li>
<li>上一个区块的哈希</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="1-3-2、分布式存储技术"><a href="#1-3-2、分布式存储技术" class="headerlink" title="1.3.2、分布式存储技术"></a>1.3.2、分布式存储技术</h3><p>与传统的数据存储技术不同，在区块链技术中，数据并不是集中存放在某个数据中心上，也不是由某个权威机构或是大多数节点来存储，而是分散存储在区块链网络中的每一个节点上。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image2.png" width="300">
</center>
<center>中心化存储</center>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image3.png" width="300">
</center>
<center>分布式存储</center>

<p><strong>节点和区块的关系是什么？</strong></p>
<p>可以用共享文档来简单描述：所有可以访问共享文档的账号就叫做节点，当然全节点需要同步共享文档，也就是拥有全部的区块数据区块就是共享文档。每个人更新了，所有人都可以查看最新的文档</p>
<h3 id="1-3-3、密码学技术"><a href="#1-3-3、密码学技术" class="headerlink" title="1.3.3、密码学技术"></a>1.3.3、密码学技术</h3><p>为了实现数据的不可逆、不可篡改和可回溯，区块链技术采用了一系列密码学算法和技术，包括哈希算法、Merkle 树、非对称加密算法。</p>
<h5 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h5><p>哈希算法是一个单向函数，可以将任意长度的输入数据转化为固定长度的输出数据（哈希值），哈希值就是这段输入数据唯一的数值表现。由于在计算上不可能找到哈希值相同而输入值不同的字符串，因此两段数据的哈希值相同，就可以认为这两段数据也是相同的，所以哈希算法常被用于对数据进行验证。</p>
<p>在区块链中，数据存储在区块里。每个区块都有一个区块头，区块头中存储了一个将该区块所有数据经过哈希算法得到的哈希值，同时，每个区块中还存储了前一个区块的哈希值，这样就形成了区块链。如果想要篡改某一个区块A中的数据，就会导致A的哈希值发生变化，后一个区块B就无法通过哈希值正确地指向A，这样篡改者又必须篡改B中的数据……也就是说，篡改者需要篡改被篡改的区块以及后面的所有区块，才能让所有的节点都接受篡改。</p>
<h5 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h5><p>Merkle树是一种树形结构，在区块链中，Merkle树的叶子节点是区块中数据的哈希值，非叶子节点是其子结点组合后的哈希值，这样由叶子节点开始逐层往上计算，最终形成一个Merkle根，记录在区块的头部，这样就可以保证每一笔交易都无法篡改。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image4.png" width="500">
</center>
<center>Merkle 树</center>

<h5 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h5><p>非对称加密技术使用两个非对称密钥：公钥和私钥。公钥和私钥具有两个特点：</p>
<ol>
<li>通过其中一个密钥加密信息后，使用另一个密钥才能解开</li>
<li>公钥一般可以公开，私钥则保密</li>
</ol>
<p>在区块链中，非对称加密技术主要用于信息加密、数字签名和登录认证。在信息加密场景中，信息发送者A使用接收者B提供的公钥对信息进行加密，B收到加密的信息后再通过自己的私钥进行解密。再数字签名场景中，发送者A通过自己的私钥对信息进行加密，其他人通过A提供的公钥来对信息进行验证，证明信息确实是由A发出。在登录认证场景中，客户端使用私钥加密登录信息后进行发送，其他人通过客户端公钥来认证登录信息。</p>
<ul>
<li><p>RSA 算法</p>
<p>​        RSA加密算法是最常用的非对称加密算法，CFCA在证书服务中离不了它。但是有不少新来的同事对它不太了解，恰好看到一本书中作者用实例对它进行了简化而生动的描述，使得高深的数学理论能够被容易地理解。<br>​       RSA是第一个比较完善的公开密钥算法，它既能用于加密，也能用于数字签名。RSA以它的三个发明者Ron Rivest, Adi Shamir, Leonard Adleman的名字首字母命名，这个算法经受住了多年深入的密码分析，虽然密码分析者既不能证明也不能否定RSA的安全性，但这恰恰说明该算法有一定的可信性，目前它已经成为最流行的公开密钥算法。<br>　　RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。 </p>
</li>
<li><p>ECC 椭圆曲线算法</p>
<p>具体可以参见此文章：<a href="https://zhuanlan.zhihu.com/p/36326221" target="_blank" rel="noopener">ECC椭圆曲线加密算法：介绍</a></p>
</li>
</ul>
<h3 id="1-3-4、共识机制"><a href="#1-3-4、共识机制" class="headerlink" title="1.3.4、共识机制"></a>1.3.4、共识机制</h3><p>区块链系统是一个分布式系统，分布式系统要解决都首要问题就是一致性问题，也就是如何使多个孤立的节点达成共识。在中心化系统中，由于有一个中心服务器这样的“领导”来统一各个节点，因此达成一致性几乎没有问题。但在去中心化场景下，由于各个节点是相互独立的，就可能会出现许多不一致的问题，例如由于网络状况等因素部分节点可能会有延迟、故障甚至宕机，造成节点之间通信的不可靠，因此一致性问题是分布式系统中一个很令人头疼的问题。</p>
<p>由 Eirc Brewer 提出，Lynch 等人证明的 CAP 定理为解决分布式系统中的一致性问题提供了思路。CAP 定理的描述如下：在分布式系统中，<strong>一致性</strong>、<strong>可用性</strong>和<strong>分区容错性</strong>三者不可兼得。这三个术语的解释如下：</p>
<ul>
<li>一致性（<strong>C</strong>onsistency）：所有节点在同一时刻拥有同样的值（等同于所有节点访问同一份最新的数据副本</li>
<li>可用性（<strong>A</strong>vailability）：每个请求都可以在有限时间内收到确定其是否成功的响应</li>
<li>分区容错性（<strong>P</strong>artition tolerance）：分区是指部分节点因为网络原因无法与其他节点达成一致。分区容错性是指由网络原因导致的系统分区不影响系统的正常运行。例如，由于网络原因系统被分为 A, B, C, D 四个区，A, B 中的节点无法正常工作，但 C, D 组成的分区仍能提供正常服务。</li>
</ul>
<p>在某些场景下，对一致性、可用性和分区容错性中的某一个特性要求不高时，就可以考虑弱化该特性，来保证整个系统的容错能力。区块链中常见的共识机制的基本思路正是来自 CAP 定理，部分区块链应用中用到的共识机制如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>共识机制</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PoW</td>
<td>比特币、莱特币、以太坊的前三个阶段</td>
</tr>
<tr>
<td>PoS</td>
<td>PeerCoin、NXT、以太坊的第四个阶段</td>
</tr>
<tr>
<td>PBFT</td>
<td>Hyperledger Fabric</td>
</tr>
</tbody>
</table>
</div>
<h5 id="PoW（Proof-of-Work，工作量证明）"><a href="#PoW（Proof-of-Work，工作量证明）" class="headerlink" title="PoW（Proof of Work，工作量证明）"></a>PoW（Proof of Work，工作量证明）</h5><p>PoW 机制的大致流程如下：</p>
<ol>
<li>向所有节点广播新交易和一个数学问题</li>
<li>最先解决了数学问题的节点将交易打包成区块，对全网广播</li>
<li>其他节点验证广播区块的节点是否解决了数学问题（完成了一定的工作量），验证通过则接受该区块，并将该区块的哈希值放入下一个区块中，表示承认该区块</li>
</ol>
<p>由于在 PoW 机制中，区块的产生需要解决一个数学问题，也就是所谓的<strong>挖矿</strong>，这往往要消耗较大的算力和电力，因此节点们倾向于在<strong>最长的链</strong>的基础上添加区块，因为如果节点想在自己的链上添加新的区块，那么就需要重新计算 1 个或 $n$ 个这样的数学问题（每添加一个区块就需要计算一个）。因此在比特币中最长的链被认为是合法的链，这样节点间就形成了一套“共识”。</p>
<p>PoW 机制的优点是完全去中心化，缺点是需要依赖数学运算，资源的消耗会比其他的共识机制高，可监管性弱，同时每次达成共识需要全网共同参与运算，性能较低。</p>
<h5 id="PoS（Proof-of-Stack，股权证明）"><a href="#PoS（Proof-of-Stack，股权证明）" class="headerlink" title="PoS（Proof of Stack，股权证明）"></a>PoS（Proof of Stack，股权证明）</h5><p>PoS 针对 PoW 的缺点做出了改进。PoS 要求参与者预先放置一些货币在区块链上用于换取“股权”，从而成为<strong>验证者（Validator）</strong>，验证者具有产生区块的权利。PoS 机制会按照存放货币的量和时间给验证者分配相应的利息，同时还引入了奖惩机制，打包错误区块的验证者将失去他的股权——即投入的货币以及产生区块的权利。PoS 机制的大致流程如下：</p>
<ol>
<li>加入 PoS 机制的都是持币人，称为验证者</li>
<li>PoS 算法根据验证者持币的多少在验证者中挑选出一个给予产生区块的权利</li>
<li>如果一定时间内没有产生区块，PoS 就挑选下一个验证者，给予产生区块的权利</li>
<li>如果某个验证者打包了一份欺诈性交易，PoS 将剥夺他的股权</li>
</ol>
<p>PoS 的优点在于：</p>
<ol>
<li>引入了利息，使得像比特币这样发币总数有限的通货紧缩系统在一定时间后不会“无币可发”</li>
<li>引入了奖惩机制使节点的运行更加可控，同时更好地防止攻击</li>
<li>与 PoW 相比，不需要为了生成新区块而消耗大量电力和算力</li>
<li>与 PoW 相比，缩短了达成共识所需的时间</li>
</ol>
<p>由于 PoS 机制需要用户已经持有一定数量的货币，没有提供在区块链应用创立初始阶段处理数字货币的方法，因此使用 PoS 机制的区块链应用会在发布时预先出售货币，或在初期采用 PoW，让矿工获得货币后再转换成 PoS，例如以太坊现阶段采用的是 PoW 机制，在第四阶段“宁静”（Serenity）中将过渡到 PoS。</p>
<h5 id="拜占庭将军问题（Byzantine-Generals-Problem）"><a href="#拜占庭将军问题（Byzantine-Generals-Problem）" class="headerlink" title="拜占庭将军问题（Byzantine Generals Problem）"></a>拜占庭将军问题（Byzantine Generals Problem）</h5><p>拜占庭将军问题是分布式网络中的通信容错问题，可以描述为：</p>
<blockquote>
<p>一组拜占庭将军各领一支队伍共同围困一座城市。各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻而部分军队撤离可能会造成灾难性的后果，因此各将军决定通过投标来达成一致策略，即“共进退”。因为各将军位于城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己的选择（进攻或撤退）通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同投票的结果，进而做出行动。</p>
</blockquote>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image1.png" width="500">
</center>



<p>拜占庭将军的问题在于，将军中可能出现叛徒。假设3名将军中有1名叛徒，2名忠诚将军一人投进攻票，一人投撤退票，这时叛徒可能会故意给投进攻的将军投进攻票，而给投撤退的将军投撤退票。这就导致一名将军带队发起进攻，而另外一名将军带队撤退。</p>
<p>另外，由于将军之间通过信使进行通讯，即使所有将军都忠诚，也不能排除信使被敌人截杀，甚至信使叛变等情况。</p>
<p>假设存在叛变将军或信使出问题等情况，如果忠诚将军仍然能够通过投票来决定他们的战略，便称系统达到了<strong>拜占庭容错（Byzantine Fault Tolerance）</strong>。</p>
<p>拜占庭问题对应到区块链中，将军就是节点，信使就是网络等通信系统，要解决的是存在恶意节点、网络错误等情况下系统的一致性问题。</p>
<p><strong>PBFT（Practical Byzantine Fault Tolerance）</strong> 是第一个得到广泛应用且比较高效的拜占庭容错算法，能够在节点数量不小于 $n=3f+1$ 的情况下容忍 $f$ 个拜占庭节点（恶意节点）。</p>
<h1 id="二、以太坊介绍"><a href="#二、以太坊介绍" class="headerlink" title="二、以太坊介绍"></a>二、以太坊介绍</h1><p>首先我们要知道我们为什么要学习以太坊，主要有以下四个原因：</p>
<ul>
<li>以太坊是区块链2.0的代表，学习以太坊能了解到区块链技术的所有知识</li>
<li>引入了智能合约，拓宽了区块链的应用场景</li>
<li>对开发者友好、对用户友好，容易编写出简单的区块链应用，学习趣味性高</li>
<li>Solidity 语法与 Javascript、Go 等语言接近，易上手</li>
</ul>
<h2 id="2-1、以太坊简介"><a href="#2-1、以太坊简介" class="headerlink" title="2.1、以太坊简介"></a>2.1、以太坊简介</h2><p>区块链技术常常被认为是自互联网诞生以来最具颠覆性的技术，然而，自比特币诞生后一直没有很好的区块链应用开发平台。想要在比特币基础上开发区块链应用是非常复杂繁琐的，因为比特币仅仅是一个加密数字货币系统，无法用来实现更广阔的业务需求。以太坊是目前使用最广泛的支持完备应用开发的共有区块链系统。</p>
<p>和比特币不同，比特币只适合加密数字货币场景，不具备图灵完备性，也缺乏保存实时状态的账户概念，以及存在 PoW 机制带来的效率和资源浪费的问题，而以太坊作为区块链2.0的代表，目标是扩展智能合约和建立一个去中心化应用平台，具有图灵完备的特性、更高效的共识机制、支持智能合约等多种应用场景，使得开发者能够很方便地在以太坊上开发出基于区块链的应用。</p>
<h3 id="2-1-1、以太坊的发展"><a href="#2-1-1、以太坊的发展" class="headerlink" title="2.1.1、以太坊的发展"></a>2.1.1、以太坊的发展</h3><p>2014年， Vitalik Buterin 发表了文章《以太坊：一个下一代智能合约和去中心化应用平台》。同年，Buterin 在迈阿密比特币会议中宣布启动以太坊项目，并提出了多项创新性的区块链技术。2015年，以太坊CCO Stephan Tual 在官方博客上宣布以太坊系统诞生，主网上线。</p>
<p>以太坊发展至今经历了“前沿”（Frontier）、“家园”（Homestead）以及现在所处的“大都会”（Metropolis）三个阶段。第四阶段“宁静”（Serenity）将作为以太坊的最后一个阶段，目前尚未有计划发布日期。</p>
<h3 id="2-1-2、以太坊的特点"><a href="#2-1-2、以太坊的特点" class="headerlink" title="2.1.2、以太坊的特点"></a>2.1.2、以太坊的特点</h3><p>以太坊团队和外界对以太坊的描述都是“世界计算机”，这代表它是一个开源的、全球的去中心化计算架构。它执行称为智能合约的程序，并使用区块链来同步和存储系统状态，以及使用名为以太币的加密数字货币来计量和约束执行操作的资源成本。同时，以太坊提供了一系列的接口，使得开发者能够通过以太坊来开发去中心化 Web 应用DApps。</p>
<h3 id="2-1-3、智能合约"><a href="#2-1-3、智能合约" class="headerlink" title="2.1.3、智能合约"></a>2.1.3、智能合约</h3><p>相比比特币，以太坊最大的特点就是引入了<strong>智能合约</strong>。智能合约本质上就是一段编写好的程序，可以在特定的条件下被触发并执行特定的操作。由于区块链具有不可逆和不可篡改的特点，因此智能合约与区块链结合后，就成了一份“强制执行”的合约。</p>
<p>以太坊能够作为一个去中心化应用平台和”世界计算机”，其核心就是智能合约。智能合约的引入，使得开发者能够实现许多（理论上是任何）业务逻辑。如果说比特币是通过区块链技术开发的特定计算器，那么引入了智能合约的以太坊就是基于区块链技术的通用计算机。可以简单的理解成：比特币的交易系统就是一份写死的智能合约，而以太坊则将智能合约的开发权限交给开发者。</p>
<p>以太坊提供了对智能合约的全面支持，包括编写智能合约编程语言 <strong>Solidity</strong> 和运行智能合约的<strong>以太坊虚拟机（Ethereum Virtual Machine，EVM）</strong>。</p>
<h3 id="2-1-4、幽灵协议"><a href="#2-1-4、幽灵协议" class="headerlink" title="2.1.4、幽灵协议"></a>2.1.4、幽灵协议</h3><p>幽灵合约的英文是“Greedy Heaviest Observed Subtree” (GHOST) protocol，在介绍幽灵协议之前，先介绍以太坊中的叔区块、叔块奖励和叔块引用奖励这三个概念。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image5.png" width="400">
</center>


<p>假设目前以太坊区块链中的区块高度（区块链上的区块个数）为6，现在产生了一笔新的交易，矿工A先将该笔交易打包成了区块 Block 7，在矿工A将 Block 7 广播到其他节点的这段时间里，矿工B和矿工C又分别产生了 Block 8 和 Block 9。Block 7、Block 8、Block 9 都指向 Block 6，即 Block 6 是他们的父区块。由于 Block 7 是最先产生的，因此 Block 7 被认为是有效区块，Block 8 和 Block 9 就是<strong>叔区块</strong>（作废区块）。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image6.png" width="300">
</center>


<p>现在链上的区块高度为7，在这基础上又产生了新的交易，并被打包成了 Block 10。在以太坊中，Block 10 除了可以引用它的父区块 Block 7 外，还可以引用叔区块 Block 8 和 Block 9。并且，Block 8 和 Block 9 的矿工会因此获得一笔奖励，称为<strong>叔块奖励</strong>，Block 10 的矿工除了基础奖励之外，由于引用了叔区块，还会获得一笔额外的<strong>叔块引用奖励</strong>。</p>
<p><strong>幽灵协议</strong>是以太坊的一大创新。由于在比特币中的出块时间被设计为10分钟，而以太坊为了提高出块速度，将出块时间设计为12秒（实际14~15秒左右），这样的高速出块意味着高速确认，高速确认会带来区块的<strong>高作废率</strong>和<strong>低安全性</strong>。因为区块需要花一定的时间才能广播至全网，如果矿工 A 挖出了一个区块，而矿工 B 碰巧在 A 的区块扩散至 B 之前挖出了另一个区块，矿工 B 的区块就会作废并且没有对区块链的网络安全做出贡献。此外，这样的高速确认还会带来<strong>中心化</strong>的问题：如果 A 拥有全网 30% 的算力而 B 拥有 10% 的算力，那么 A 将会在 70% 的时间内都在产生作废区块，而 B 在 90% 的时间内都在产生作废区块，这样，B 永远追不上 A，后果是 A 通过其算力份额拥有对挖矿过程实际上的控制权，出现了算力垄断，弱化了去中心化。</p>
<p>幽灵协议正是为了解决上述问题而引入的，协议的主要内容如下：</p>
<ul>
<li>计算最长链时，不仅包括当前区块的父区块和祖区块，还包括祖先块的作废的后代区块（叔区块），将它们综合考虑来计算哪一个区块拥有支持其的最大工作量证明。这解决了网络安全性的问题</li>
<li>以太坊付给以“叔区块”身份为新块确认作出贡献的废区块87.5%的奖励（叔块奖励），把它们纳入计算的“侄子区块”将获得奖励的12.5%（叔块引用奖励）。这就使得即使产生作废区块的矿工也能够参与区块链网络贡献并获得奖励，解决了中心化倾向的问题</li>
<li>叔区块最深可以被其父母的第二代至第七代后辈区块引用。这样做是为了：<ul>
<li>降低引用叔区块的计算复杂性</li>
<li>过多的叔块引用奖励会剥夺矿工在主链上挖矿的激励，使得矿工有转向公开攻击者链上挖矿的倾向（即公开攻击者可能会恶意产生大量作废区块，无限引用将会诱使矿工转移到攻击者的链上，从而抛弃合法的主链）</li>
<li>计算表明带有激励的五层幽灵协议即使在出块时间为15s的情况下也实现了了95%以上的效率，而拥有25%算力的矿工从中心化得到的益处小于3%</li>
</ul>
</li>
</ul>
<h3 id="2-1-5、以太坊的组成部分"><a href="#2-1-5、以太坊的组成部分" class="headerlink" title="2.1.5、以太坊的组成部分"></a>2.1.5、以太坊的组成部分</h3><p>在以太坊中，包括了 P2P 网络、共识机制、交易、状态机、客户端这几个组成部分。</p>
<ul>
<li>P2P 网络：在以太坊主网上运行，可通过TCP端口30303访问，并运行称为 ÐΞVp2p 的协议。</li>
<li>共识机制：以太坊目前使用名为 Ethash 的 POW 算法，计划在将来会过渡到称为 Casper 的 POS 算法。</li>
<li>交易：以太坊中的交易本质上是网络消息，包括发送者、接收者、值和数据载荷（payload）。</li>
<li>状态机：以太坊的状态转移由以太坊虚拟机（Ethereum Virtual Machine，EVM）处理，EVM 能够将智能合约编译成机器码并执行。</li>
<li>客户端：用于用户和以太坊进行交互操作的软件实现，最突出的是 Go-Ethereum(Geth) 和 Parity。</li>
</ul>
<h3 id="2-1-6、以太坊中的概念"><a href="#2-1-6、以太坊中的概念" class="headerlink" title="2.1.6、以太坊中的概念"></a>2.1.6、以太坊中的概念</h3><ul>
<li>账户：以太坊中的账户类似于银行账户、应用账户，每个账户有一个20字节的地址。账户又分为<strong>普通账户</strong>（又叫外部账户，External Owned Account, EOA）和<strong>合约账户</strong>（Contract）。普通账户是由以太坊使用者创建的账户，包含地址、余额和随机数；合约账户是创建智能合约时建立的账户，包含存储空间和合约代码</li>
<li>状态：状态是由账户和两个账户之间价值的转移以及信息的状态转换构成的</li>
<li>地址：地址是一个账户 ECDSA 公钥的 Keccak 散列最右边的160位，通过地址可以在以太坊上接收或发送交易。在 Etherscan 上，可以通过地址来查询一个账户的信息</li>
<li>交易：以太坊中的交易不仅包括发送和接收以太币，还包括向合约账户发送交易来调用合约代码、向空用户发送交易来生成以交易信息为代码块的合约账户</li>
<li>Gas：Gas 是以太坊中的一种机制，用于执行智能合约或交易操作的虚拟燃料。由于以太坊是图灵完备的，为了避免开发者无意或恶意编写出死循环等浪费资源或滥用资源的情况，以太坊中的每一笔交易都需支付一定的 Gas （燃料费），即需支付一定的以太币作为 Gas。Gas 的金额通常是由交易的发起者指定并支付的</li>
<li>挖矿：和比特币类似，以太坊同样通过挖矿来产生区块。在以太坊目前的 PoW 机制下，每当一笔交易发出并广播，就会吸引矿工来将该交易打包成区块。每产生一个区块都会有一笔<strong>固定奖励</strong>给矿工，目前的固定奖励是3个以太。同时，区块中所有操作所需的 Gas 也会作为奖励给矿工。与比特币不同的是，以太坊中产生叔块的矿工可能会获得叔块奖励，引用叔块的矿工会获得叔块引用奖励</li>
<li>DApp（去中心化应用）：通过智能合约，开发者能够设计想要的逻辑，相当于是网站的后端。而 DApp 则相当于是一个完整的网站（前端+后端），因此 DApp = 智能合约 + Web 前端。以太坊提供了一个名为 web3.js 的 Javascript 库，通过 web3.js 可以实现 Web 与以太坊区块链的交互和与智能合约的交互，方便开发者创建 DApp</li>
</ul>
<h2 id="2-2、以太坊基础"><a href="#2-2、以太坊基础" class="headerlink" title="2.2、以太坊基础"></a>2.2、以太坊基础</h2><h3 id="2-2-1、以太坊中的货币"><a href="#2-2-1、以太坊中的货币" class="headerlink" title="2.2.1、以太坊中的货币"></a>2.2.1、以太坊中的货币</h3><p>以太坊中的货币称为 <strong>以太币</strong>，单位为<strong>以太（Ether）</strong>，也称 ETH 或符号 Ξ。以太可以被分割为更小的单位，最小的单位是 wei，1 以太 =  $10^18$  wei。以太币各单位的名称及之间的关系如下表：</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219000835894.png">
</center>





<h3 id="2-2-2、以太坊钱包"><a href="#2-2-2、以太坊钱包" class="headerlink" title="2.2.2、以太坊钱包"></a>2.2.2、以太坊钱包</h3><p>以太坊钱包是用于创建和广播交易的应用程序，常用的钱包有</p>
<ul>
<li>MetaMask，一款基于浏览器扩展的钱包，可以很方便地添加到 Chrome, FireFox 等支持扩展的浏览器中</li>
<li>Jaxx，一款跨平台、多币种的钱包</li>
<li>MyEtherWallet(MEW)，一款基于 Web 的钱包，可以在任何浏览器中运行</li>
<li>Emerald Wallet，一款被设计来用于以太坊经典区块链的钱包，但也与其他以太坊区块链兼容</li>
</ul>
<h4 id="MetaMask-基础"><a href="#MetaMask-基础" class="headerlink" title="MetaMask 基础"></a>MetaMask 基础</h4><p>以 Chrome 为例，访问 <a href="https://chrome.google.com/webstore/category/extensions" target="_blank" rel="noopener">Google 网上应用商店</a>，搜索 MetaMask 并添加至 Chrome</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101124978.png">
</center>


<p>添加完成后 Chrome 会自动打开初始化页面</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101226095.png">
</center>



<p>初次使用创建钱包</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101300792.png">
</center>



<p>为钱包设置密码</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219101332089.png">
</center>




<p>创建密码后，MetaMask 会生成一串密语，密语是12个随机的英文单词，用于防止密码忘记。密语可以直接当成密码使用，因此需要妥善保管</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219102028033.png">
</center>



<p>注册完毕后就可以在 Chrome 地址栏右边的扩展程序栏点击 🦊 图标使用 MetaMask 了</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219102255927.png">
</center>

<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219102322360.png">
</center>

<h4 id="获取测试以太"><a href="#获取测试以太" class="headerlink" title="获取测试以太"></a>获取测试以太</h4><p>除了以太坊主网以外，以太坊还提供了 Ropsten, Kovan, Rinkeby, Goerli 这几个公共测试网络，另外还支持局域网测试网络和自建测试网络。在这里我们切换到 Ropsten 测试网络</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219105616335.png">
</center>




<p>随后点击 <strong>Buy</strong> 按钮，点击<strong>测试水管</strong>下方的获取以太</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219105824087.png">
</center>




<p>在打开的页面中点击 request 1 ether from faucet 就可以得到1个测试以太，当然，可以多次点击。</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\image-20210219105911910.png">
</center>


<center class="half">
    <img src="\Pic\Blockchain_Pic\2021-02-19_110327.png">
</center>


<p>测试以太仅供测试使用，除此之外没有任何价值，测试完毕后剩下的以太可以发送到水龙头账户捐赠给水龙头，以供他人测试使用。</p>
<h2 id="2-3、以太坊交易的数据结构"><a href="#2-3、以太坊交易的数据结构" class="headerlink" title="2.3、以太坊交易的数据结构"></a>2.3、以太坊交易的数据结构</h2><p>在以太坊网络中，交易执行属于一个事务。具有原子性、一致性、隔离性、持久性特点。</p>
<ul>
<li>原子性： 是不可分割的最小执行单位，要么做，要么不做。</li>
<li>一致性： 同一笔交易执行，必然是将以太坊账本从一个一致性状态变到另一个一致性状态。</li>
<li>隔离性： 交易执行途中不会受其他交易干扰。</li>
<li>持久性： 一旦交易提交，则对以太坊账本的改变是永久性的。后续的操作不会对其有任何影响。</li>
</ul>
<p>以太坊交易的本质是由外部拥有的账户发起的签名消息，由以太坊网络传输，并被序列化后记录在以太坊区块链上，<strong>交易是唯一可以触发状态更改或导致合约在EVM中执行的事物</strong></p>
<h3 id="2-3-1、交易的数据结构"><a href="#2-3-1、交易的数据结构" class="headerlink" title="2.3.1、交易的数据结构"></a>2.3.1、交易的数据结构</h3><p>以太坊的数据结构主要可以分为四部分：<code>nonce</code>、<code>gas</code>、交易目标和消息（主要部分）、交易签名</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\transaction-struct.png">
</center>



<p>开头是一个 uint64 类型的数字，称之为随机数。用于撤销交易、防止双花和修改以太坊账户的 Nonce 值。</p>
<p>第二部分是关于交易执行限制的设置，gas 为愿意供以太坊虚拟机运行的燃料上限。 <code>gasPrice</code> 是愿意支付的燃料单价。<code>gasPrcie * gas</code> 则为愿意为这笔交易支付的最高手续费。</p>
<p>第三部分是交易发送者输入以太坊虚拟机执行此交易的初始信息： 虚拟机操作对象（接收方 To）、从交易发送方转移到操作对象的资产（Value），以及虚拟机运行时入参(input)。其中 To 为空时，意味着虚拟机无可操作对象，<strong>此时虚拟机将利用 input 内容部署一个新合约</strong>。</p>
<p>第四部分是交易发送方对交易的签名结果，可以利用交易内容和签名结果反向推导出签名者，即交易发送方地址。以上总结如下：</p>
<ul>
<li><code>nonce</code>：由发起人EOA发出的序列号，用于防止交易消息重播。</li>
<li><code>gas price</code>：交易发起人愿意支付的gas单价（wei）。</li>
<li><code>start gas</code>：交易发起人愿意支付的最大gas量。</li>
<li><code>to</code>：目的以太坊地址。</li>
<li><code>value</code>：要发送到目的地的以太数量。</li>
<li><code>data</code>：可变长度二进制数据负载（payload）。</li>
<li><code>v,r,s</code>：发起人EOA的ECDSA签名的三个组成部分。</li>
<li>交易消息的结构使用递归长度前缀（RLP）编码方案进行序列化，该方案专为在以太坊中准确和字节完美的数据序列化而创建。</li>
</ul>
<h3 id="2-3-2、交易中的nonce"><a href="#2-3-2、交易中的nonce" class="headerlink" title="2.3.2、交易中的nonce"></a>2.3.2、交易中的<code>nonce</code></h3><p>按以太坊黄皮书的定义， <code>nonce</code>是一个标量值，它等于从这个地址发送的交易数，或者对于关联code的帐户来说，是这个帐户创建合约的数量。因此<code>nonce</code>便有以下特征：</p>
<ul>
<li><code>nonce</code>不会明确存储为区块链中帐户状态的一部分。相反，它是通过计算发送地址的已确认交易的数量来动态计算的。</li>
<li><code>nonce</code>值还用于防止错误计算账户余额。<code>nonce</code>强制来自任何地址的交易按顺序处理，没有间隔，无论节点接收它们的顺序如何。</li>
<li>使用<code>nonce</code>确保所有节点计算相同的余额和正确的序列交易，等同于用于防止比特币“双重支付”（“重放攻击”）的机制。但是，由于以太坊跟踪账户余额并且不单独跟踪 <code>UTXO</code> ，因此只有在错误地计算账户余额时才会发生“双重支付”。<code>nonce</code>机制可以防止这种情况发生。</li>
</ul>
<h3 id="2-3-3、并发和nonce"><a href="#2-3-3、并发和nonce" class="headerlink" title="2.3.3、并发和nonce"></a>2.3.3、并发和<code>nonce</code></h3><p>以太坊是一个允许操作（节点，客户端，DApps）并发的系统，但强制执行单例状态。例如，出块的时候只有一个系统状态。假如我们有多个独立的钱包应用或客户端，比如 MetaMask 和 Geth，它们可以使用相同的地址生成交易。如果我们希望它们都够同时发送交易，该怎么设置交易的<code>nonce</code>呢？一般有以下两种做法：</p>
<ul>
<li>用一台服务器为各个应用分配<code>nonce</code>，先来先服务——可能出现单点故障，并且失败的交易会将后续交易阻塞。</li>
<li>生成交易后不分配<code>nonce</code>，也不签名，而是把它放入一个队列等待。另起一个节点跟踪<code>nonce</code>并签名交易。同样会有单点故障的可能，而且跟踪<code>nonce</code>和签名的节点是无法实现真正并发的。</li>
</ul>
<h3 id="2-3-4、交易中的gas"><a href="#2-3-4、交易中的gas" class="headerlink" title="2.3.4、交易中的gas"></a>2.3.4、交易中的<code>gas</code></h3><p>Gas 中译是：瓦斯、汽油，代表一种可燃气体。 这形象地比喻以太坊的交易手续费计算模式，不同于比特币中<strong>直接</strong>支付比特币作为转账手续费， 以太坊视为一个去中心化的计算网络，当你发送Token、执行合约、转移以太币或者在此区块上干其他的时候，计算机在处理这笔交易时需要进行计算消耗网络资源，这样你必须支付燃油费购买燃料才能让计算机为你工作。最终燃料费作为手续费支付给矿工。</p>
<blockquote>
<p>注：可以在Etherscan上查询gas price与confirmation time的关系，如下图</p>
</blockquote>
<center class="half">
    <img src="\Pic\Blockchain_Pic\gas.jpg">
</center>


<p>因为手续费等于<code>gasPrice * gasUsed</code>，用户在转账，特别是执行智能合约时 gasUsed 无法提前预知。 这样存在一个风险，当用户的交易涉及一个恶意的智能合约，该合约执行将消耗无限的燃料， 这样会导致交易方的余额全部消耗（恶意的智能合约有可能是程序Bug，如合约执行陷入一个死循环）。</p>
<p>为了避免合约中的错误引起不可预计的燃料消耗，用户需要在发送交易时设定允许消耗的燃料上限，即 gasLimit。 这样不管合约是否良好，最坏情况也只是消耗 gasLimit 量的燃料。</p>
<p>然而，一笔交易所必须支付的燃料已经在区块中通过该交易已执行的计算量记录。 如果你不想支出太多燃料，而故意设置过低的 gasLimit 是没太多帮助的。 你必须支付足够燃料来支付本交易所必要的计算资源。如果交易尚未执行完成，而燃料已用完， 将出现一个 <code>Out of Gas</code> 的错误。特别注意的是，即使交易失败，你也必须为已占用的计算资源所支付手续费。 比如，你通过合约给 TFBOYS 投票，设置 gasPrice=2 gwei，gasLimit=40000（实现投票需要40001的燃料开销）， 最终你投票失败且仍然需要支付 40000*2 gwei= 80000 gwei= 0.00008 ETH。</p>
<p>另外，如果最终 gasUsed 低于 gasLimit，即燃料未用完。则剩余燃料(gasLimit - gasUsed )将在交易后退还给你。 比如你发送 1 Ether 到另一个账户B，设置 gas limit 为 400000，将有 400000 - 21000 返回给你。</p>
<blockquote>
<p>注意：21000 是标准转账交易的gasUsed。因此一笔标准的转账交易你可以设置 gasLimit 为21000</p>
</blockquote>
<h2 id="2-4、以太坊账户"><a href="#2-4、以太坊账户" class="headerlink" title="2.4、以太坊账户"></a>2.4、以太坊账户</h2><p>对比比特币的UTXO余额模型，以太坊使用“账户”余额模型。 以太坊丰富了账户内容，除余额外还能自定义存放任意多数据。 并利用账户数据的可维护性，构建智能合约账户。下面我们首先将比特币的UTXO余额模型与以太坊账户进行比较，说明其各自的优缺点以及适用性。</p>
<h3 id="2-4-1、比特币UTXO和以太坊账户结构比较"><a href="#2-4-1、比特币UTXO和以太坊账户结构比较" class="headerlink" title="2.4.1、比特币UTXO和以太坊账户结构比较"></a>2.4.1、比特币UTXO和以太坊账户结构比较</h3><p>在当前的区块链项目中，主要有两种记录保存方式，<strong>一种是账户/余额模型，一种是UTXO模型</strong>。比特币采用就是UTXO模型，以太坊、EOS等则采用的是账户/余额模型。</p>
<p><img src="\Pic/utxo_com.jpg" style="zoom:67%;"></p>
<h3 id="2-4-2、比特币UTXO"><a href="#2-4-2、比特币UTXO" class="headerlink" title="2.4.2、比特币UTXO"></a>2.4.2、比特币UTXO</h3><p>UTXO是 Unspent Transaction Output的缩写，意思是<strong>未花费的输出，</strong>可以简单理解为还没有用掉的收款。比如韩梅梅收到一笔比特币，她没有用掉，这笔比特币对她来说就是一个UTXO。关于UTXO的具体介绍大家可以查看<a href="https://zhuanlan.zhihu.com/p/74050135" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><strong>UTXO 核心设计思路是：它记录交易事件，而不记录最终状态。</strong>要计算某个用户有多少比特币，就要对其钱包里所有的UTXO求和，得到结果就是他的持币数量。UTXO模型在转账交易时，是以UTXO为单位的，也就是说在支付时，调用的是整数倍UTXO，比如1个UTXO，3个UTXO，没有0.5个UTXO的说法。</p>
<ul>
<li>比特币在基于UTXO的结构中存储有关用户余额的数据，系统的整个状态就是一组UTXO的集合，每个UTXO都有一个所有者和一个面值（就像不同的硬币），而交易会花费若干个输入的UTXO，并根据规则创建若干个新的UTXO</li>
<li>每个引用的输入必须有效并且尚未花费，对于一个交易，必须包含有每个输入的所有者匹配的签名，总输入必须大于等于总输出值。所以系统中用户的余额是用户具有私钥的UTXO的总值</li>
</ul>
<h3 id="2-4-3、以太坊账户"><a href="#2-4-3、以太坊账户" class="headerlink" title="2.4.3、以太坊账户"></a>2.4.3、以太坊账户</h3><p>为什么以太坊不用UTXO呢？显然是因为麻烦，以太坊的做法更符合直觉，以太坊中的状态就是系统中所有账户的列表，每个账户都包含了一个余额和以太坊<strong>特殊定义的数据</strong>（代码和内部存储）。如果发送账户有足够多的余额来进行支付，则交易有效，在这种情况下发送账户先扣款，而收款账户将记入这笔收入。<strong>如果接受账户有相关代码，则代码会自动运行，并且它的内部存储也可能被更改，或者代码还可能向其他账户发送额外的消息，这就会导致进一步的借贷资金关系。</strong></p>
<h3 id="2-4-4、优缺点比较"><a href="#2-4-4、优缺点比较" class="headerlink" title="2.4.4、优缺点比较"></a>2.4.4、优缺点比较</h3><p><strong>比特币UTXO的优点</strong>：</p>
<ul>
<li>更高程度的隐私：如果用户为他们收到的每笔交易使用新地址，那么通常很难将账户互相链接。这很大程度上适用于货币，但不太适用于任何dapps，因为dapps通常涉及跟踪和用户绑定的复杂状态，可能不存在像货币那样简单的用户状态划分方案</li>
<li>潜在的可扩展性：UTXO在理论上更符合可扩展性要求，因为我们只需要依赖拥有UTXO的那些人去维护基于Merkle树的所有权证明就够了，即使包括所有者在内的每个人都决定忘记该数据，那么也只有所有者受到对应的UTXO的损失，不影响接下来的交易。而在账户模式中，如果每个人都丢失了与账户相对应的Merkle树的部分，那将会使得和该账户有关的消息完全无法处理，包括发币给它。</li>
</ul>
<p><strong>以太坊账户模式的优点</strong>：</p>
<ul>
<li>可以节省大量空间：不将UTXOs分开存储，而是合成一个账户；每个交易只需要一个输入、一个签名并产生一个输出</li>
<li>更好的可替代性：货币本质上都是同质化、可替代的；UTXO的设计使得货币从来源分成了“可花费”和“不可花费”两类，这在实际应用中很难有对应模型</li>
<li>更加简单：更容易编码和理解，特别是设计复杂脚本的时候，UTXO的脚本逻辑复杂时更令人费解</li>
<li>便于维护持久轻节点：只要沿着特定方向扫描状态树，轻节点 可以很容易地随时访问账户相关的所有数据。而UTXO地每个交易都会使得状态引用发生改变，这对应节点来说长时间运行Dapp会有很大压力</li>
</ul>
<h3 id="2-4-5、总结"><a href="#2-4-5、总结" class="headerlink" title="2.4.5、总结"></a>2.4.5、总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>BitCoin</th>
<th>Ethereum</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设计定位</strong></td>
<td>现金系统</td>
<td>去中心化应用平台</td>
</tr>
<tr>
<td><strong>数据组成</strong></td>
<td>交易列表（账本）</td>
<td>交易和账户状态</td>
</tr>
<tr>
<td><strong>交易对象</strong></td>
<td>UTXO</td>
<td>Accounts</td>
</tr>
<tr>
<td><strong>代码控制</strong></td>
<td>脚本</td>
<td>智能合约</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-5、以太坊账户类型"><a href="#2-5、以太坊账户类型" class="headerlink" title="2.5、以太坊账户类型"></a>2.5、以太坊账户类型</h2><p>以太坊作为智能合约操作平台，将账户划分为两类：外部账户（EOAs）和合约账户（contract account），下面分别做简要介绍：</p>
<center class="half">
    <img src="\Pic\Blockchain_Pic\EOA_CA.png">
</center>



<h3 id="2-5-1、外部账户（EOA）"><a href="#2-5-1、外部账户（EOA）" class="headerlink" title="2.5.1、外部账户（EOA）"></a>2.5.1、外部账户（EOA）</h3><p>外部账户是由人来控制的，也就是常规理解的普通账户，外部账户包含以太币余额，主要作用就是发送交易（是广义的交易，包括转币和触发合约代码），是由用户私钥控制的，没有关联代码，所有在以太坊上交易的发起者都是外部账户。</p>
<p>外部账户特点总结：</p>
<ol>
<li>拥有以太余额。</li>
<li>能发送交易，包括转账和执行合约代码。</li>
<li>被私钥控制。</li>
<li>没有相关的可执行代码。</li>
</ol>
<h3 id="2-5-2、合约账户（CA）"><a href="#2-5-2、合约账户（CA）" class="headerlink" title="2.5.2、合约账户（CA）"></a>2.5.2、合约账户（CA）</h3><p>合约账户有时也叫内部账户，有对应的以太币余额和关联代码，它是由代码控制的，可以通过交易或来自其他合约的调用消息来触发代码执行，执行代码时可以操作自己的存储空间，也可以调用其他合约</p>
<p>合约账户特点总结：</p>
<ol>
<li>拥有以太余额。</li>
<li>有相关的可执行代码（合约代码）。</li>
<li>合约代码能够被交易或者其他合约消息调用。</li>
<li>合约代码被执行时可再调用其他合约代码。</li>
<li>合约代码被执行时可执行复杂运算，可永久地改变合约内部的数据存储。</li>
</ol>
<p>如果大家对概念还理解不深可以先尝试学习后面部分，本教程内容有限，推荐大家有精力阅读以下读物：</p>
<ul>
<li><a href="https://www.zhihu.com/question/61156867" target="_blank" rel="noopener">区块链学习的书籍</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">区块链入门教程</a></li>
<li><a href="https://developer.ibm.com/zh/technologies/blockchain/tutorials/" target="_blank" rel="noopener">IBM教程</a></li>
</ul>
<p><strong>参考自：</strong></p>
<ol>
<li>[比特币白皮书]<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system" target="_blank" rel="noopener">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a>)</li>
<li><a href="https://ethfans.org/posts/ethereum-whitepaper" target="_blank" rel="noopener">以太坊白皮书</a></li>
<li><a href="https://www.chainnode.com/doc/399" target="_blank" rel="noopener">超级账本白皮书</a></li>
<li><a href="https://www.chainnode.com/doc/399" target="_blank" rel="noopener">闪电网络白皮书</a></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://chenkai66.github.io/posts/fb46f828.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/posts/f6ff6959.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            区块链入门（三）Solidity基础
          
        </div>
      </a>
    
    
      <a href="/posts/cf0a3f0.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">区块链入门（一）Linux基础</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "TQy5bHTePagP10u5BBsesx61-gzGzoHsz",
    app_key: "O6UyJYxBFgMKQMjktBh4KGad",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> chenk
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 帅气的CK本尊 强力驱动
        
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="言念君子"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haruto"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>