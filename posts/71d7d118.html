<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    matlab/Matlab数字图像处理初步 |  言念君子
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-matlab/Matlab数字图像处理初步"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  matlab/Matlab数字图像处理初步
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/71d7d118.html" class="article-date">
  <time datetime="2021-06-10T00:51:33.433Z" itemprop="datePublished">2021-06-10</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">16 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="灰度数字图像与矩阵"><a href="#灰度数字图像与矩阵" class="headerlink" title="灰度数字图像与矩阵"></a>灰度数字图像与矩阵</h1><ul>
<li><strong>灰度图像</strong>：一张灰度图像根据其竖直位置（行）与水平位置（列）可以对应于一个二维矩阵$𝒇(𝒙,𝒚),𝟏≤𝒙≤𝑴,𝟏≤𝒚≤𝑵$，其中$(𝑴,𝑵)$为图像的尺寸。而$𝒇(𝒙,𝒚)$表示的为图像的灰度，图像灰度值通常在数据文件中以<code>uint8</code>，即八位无符号整型$(0, 255)$的整数来表示灰度。0为黑色，255为白色。</li>
</ul>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215101026301.png" alt="image-20201215101026301"></p>
<ul>
<li><strong>彩色图像</strong>：彩色图像最为常用的存储模式为RGB存储模式，即彩色图像的红、绿、蓝三种颜色分别对应一种亮度（灰度）值。记为$𝒇(𝒙,𝒚,𝒛),𝟏≤𝒙≤𝑴,𝟏≤𝒚≤𝑵,𝒛∈{𝟏,𝟐,𝟑}$</li>
</ul>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215101132611.png" alt="image-20201215101132611" style="zoom:67%;"></p>
<p>​    <strong>注意：jpg文件为有损压缩，png文件为无损压缩</strong></p>
<h1 id="数字图像基础API"><a href="#数字图像基础API" class="headerlink" title="数字图像基础API"></a>数字图像基础API</h1><ul>
<li><p><strong>信息获取</strong>：函数<code>info=imfinfo(&#39;filename&#39;)</code>可获取灰度或彩色图像文件的基本信息，如假设文件名为<code>mcm1.png</code>，可见：</p>
<p>例如我展示一个图片的信息，结果为：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">info &#x3D; </span><br><span class="line"></span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line"></span><br><span class="line">           Filename: &#39;D:\matlab\AFile\temp\pic\songshu.jpg&#39;</span><br><span class="line">        FileModDate: &#39;26-Jul-2020 15:49:11&#39;</span><br><span class="line">           FileSize: 720467</span><br><span class="line">             Format: &#39;jpg&#39;</span><br><span class="line">      FormatVersion: &#39;&#39;</span><br><span class="line">              Width: 1920</span><br><span class="line">             Height: 1080</span><br><span class="line">           BitDepth: 24</span><br><span class="line">          ColorType: &#39;truecolor&#39;</span><br><span class="line">    FormatSignature: &#39;&#39;</span><br><span class="line">    NumberOfSamples: 3</span><br><span class="line">       CodingMethod: &#39;Huffman&#39;</span><br><span class="line">      CodingProcess: &#39;Progressive&#39;</span><br><span class="line">            Comment: &#123;&#125;</span><br><span class="line">        Orientation: 1</span><br><span class="line">        XResolution: 72</span><br><span class="line">        YResolution: 72</span><br><span class="line">     ResolutionUnit: &#39;Inch&#39;</span><br><span class="line">           Software: &#39;Adobe Photoshop CS Windows&#39;</span><br><span class="line">           DateTime: &#39;2017:02:26 10:40:49&#39;</span><br><span class="line">      DigitalCamera: [1×1 struct]</span><br><span class="line">      ExifThumbnail: [1×1 struct]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>读取图像</strong>：进入图像所在的文件夹，键入<code>A=imread(&#39;filename&#39;)</code>，即可获取灰度或彩色图像的信息，并且将其储存在矩阵A中</p>
</li>
<li><p><strong>展示图像</strong>：MATLAB函数<code>imshow(A)</code>可以弹出Figure并显示图像A</p>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li>数字图像的默认储存格式<code>uint8</code>并不适合进行数值计算。在进行数值计算时，矩阵往往被自动转化成双精度型。因此图示前往往将矩阵强制转换为<code>uint8</code>型。</li>
<li>对双精度型矩阵,直接使用<code>imshow</code>默认最小值为0,最大值为1。0~255双精度图像可标准化图示如<code>imshow(A/255)</code></li>
</ol>
<h1 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h1><h2 id="彩色图像的通道分离与图像存储"><a href="#彩色图像的通道分离与图像存储" class="headerlink" title="彩色图像的通道分离与图像存储"></a>彩色图像的通道分离与图像存储</h2><p>对于RGB格式的彩色图像矩阵A，<code>B=A(:,:,1)</code>即可提取彩色图像的红色通道值,其中B将以二维矩阵的形式存储表示</p>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215102333149.png" alt="image-20201215102333149"></p>
<p>相应API：</p>
<ul>
<li><p><code>imshow(B)</code>：将会得到对应红色通道的灰度图像</p>
</li>
<li><p><code>C=rgb2gray(A)</code>：可以根据彩色图像A的整体亮度均匀的转化为灰度图像C</p>
</li>
<li><p><code>imwrite(A,&#39;file_name&#39;)</code>可以将任何的灰度或彩色图像矩阵存入对应文件名。注意：<code>double</code>型矩阵存储时范围为0~1</p>
</li>
</ul>
<h2 id="彩色图像的颜色编码更换"><a href="#彩色图像的颜色编码更换" class="headerlink" title="彩色图像的颜色编码更换"></a>彩色图像的颜色编码更换</h2><p>RGB格式是大多数彩色图像的存储格式，按照红、绿、蓝三种颜色分别存储一张灰度图像。另一种非常流行的颜色模型为HSV模型，分为色调(Hue),饱和度(Saturation)以及明度(Value)三种信息</p>
<p><code>B = rgb2hsv(A)</code>，可以将RGB模型的矩阵A化为<code>hsv</code>型的矩阵B，而<code>C=hsv2rgb(B)</code>可以完成逆变换。若A为<code>uint8</code>型的数据，则会自动转为双精度型并除以255，再进行对应的色彩空间变换，<strong>HSV的指标范围均为0~1</strong></p>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215102736379.png" alt="image-20201215102736379"></p>
<h1 id="数字图像的简单处理"><a href="#数字图像的简单处理" class="headerlink" title="数字图像的简单处理"></a>数字图像的简单处理</h1><p><strong>数字图像的放大</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGB2 = imresize(RGB,[<span class="number">192</span>,<span class="number">256</span>]); 	<span class="comment">% 图像长宽减半</span></span><br></pre></td></tr></table></figure>
<p><strong>数字图像的放大</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGB3=imresize(RGB,[<span class="number">1000</span>,NaN]); 		<span class="comment">% 等比例放大</span></span><br></pre></td></tr></table></figure>
<p><em>Matlab默认使用双三次插值的方法获取更大的图像</em></p>
<p><strong>数字图像的裁剪</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RGB4=RGB3(<span class="number">401</span>:<span class="number">600</span>,<span class="number">401</span>:<span class="number">600</span>,:);		<span class="comment">% 将前页放大图像的第401~600行，401~600列裁剪下来</span></span><br><span class="line">RGB5=RGB3(<span class="number">600</span>:<span class="number">-1</span>:<span class="number">401</span>,<span class="number">600</span>:<span class="number">-1</span>:<span class="number">401</span>,:); <span class="comment">% 与上述结果相比，进行了水平和垂直翻转</span></span><br><span class="line">RGB6=RGB3(<span class="number">1</span>:<span class="number">2</span>:<span class="keyword">end</span>,<span class="number">1</span>:<span class="number">2</span>:<span class="keyword">end</span>,:);		<span class="comment">% 本质上是一种“粗暴”的图像缩小算法</span></span><br></pre></td></tr></table></figure>
<p><strong>数字图像映射到曲面</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x,y,z] = sphere(<span class="number">100</span>);  <span class="comment">%生成101层高度的单位球面坐标，每层101X101个点坐标</span></span><br><span class="line">warp(x,y,z,RGB)			<span class="comment">%将彩椒图像映射到球面显示</span></span><br><span class="line">view(<span class="number">45</span>,<span class="number">-45</span>)			<span class="comment">%改变观察角度，也改变了图像相对位置</span></span><br></pre></td></tr></table></figure>
<h1 id="数字图像的亮度与对比度"><a href="#数字图像的亮度与对比度" class="headerlink" title="数字图像的亮度与对比度"></a>数字图像的亮度与对比度</h1><p><strong>亮度</strong>：设<code>uint8</code>型的灰度图像的二维矩阵为A，设置常整数<code>-255&lt;=c&lt;=255</code>，则<code>A+c</code>就表示亮度的调整。若<code>A+c</code>超过255则自动设置为255，反之若<code>A+c</code>小于0则自动设置为0</p>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215103533478.png" alt="image-20201215103533478" style="zoom:67%;"></p>
<p><strong>对比度</strong>：设<code>uint8</code>型的灰度图像的矩阵为A,设置正常数<code>c&gt;0</code>与<code>0~255</code>之间的整数<code>k</code>，则$c*(A-k)+k$则表示以<code>k</code>为灰度中心，将对比放大/缩小<code>c</code>倍。通常，因对比度常定义为最大最小灰度比值，故假设<code>k=0</code>，注意：结果仍会自动转化为<code>uint8</code>型的数据。</p>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215103730624.png" alt="image-20201215103730624" style="zoom:67%;"></p>
<h1 id="图像的直方图显示与均衡化"><a href="#图像的直方图显示与均衡化" class="headerlink" title="图像的直方图显示与均衡化"></a>图像的直方图显示与均衡化</h1><ul>
<li><code>imhist(A)</code>可绘制图像的灰度直方图，统计各灰度出现频率</li>
<li><code>B = histeq(A)</code>可将矩阵A进行灰度均衡化(一般增大对比度)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I=imread(<span class="string">'peppers.png'</span>);   	<span class="comment">%读取图像并在左上角显示其灰度</span></span><br><span class="line">I=rgb2gray(I); </span><br><span class="line"><span class="built_in">figure</span>;subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(I);</span><br><span class="line">title(<span class="string">'原始图像'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);			<span class="comment">%绘制直方图</span></span><br><span class="line">imhist(I);</span><br><span class="line">title(<span class="string">'原始图像直方图'</span>);</span><br><span class="line"></span><br><span class="line">I1=histeq(I);     			<span class="comment">%图像均衡化后的效果</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">imshow(I1);title(<span class="string">'图像均衡化'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">imhist(I1);</span><br><span class="line">title(<span class="string">'直方图均衡化'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215104123317.png" alt="image-20201215104123317" style="zoom:67%;"></p>
<h1 id="图像的背景提取与计算"><a href="#图像的背景提取与计算" class="headerlink" title="图像的背景提取与计算"></a>图像的背景提取与计算</h1><p>图像的背景提取可以基于图像的开运算算法(属于形态学图像基础，这里对原理不作要求)，对应的MATLAB函数为<code>imopen</code>，开运算的核心是对图像的腐蚀再膨胀的运算，主要效果除了对细节平滑化外，可以去掉前景亮色的边缘毛刺等，后面将专门介绍。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clear all;coins=imread(<span class="string">'coins.png'</span>);	<span class="comment">%打开MATLAB內建的硬币图像</span></span><br><span class="line">background=imopen(coins,strel(<span class="string">'disk'</span>,<span class="number">15</span>));</span><br><span class="line"><span class="comment">%利用半径为15的圆盘做开运算</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(coins);title (<span class="string">'原始图像'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);imshow(background);title (<span class="string">'背景图像'</span>)</span><br><span class="line"><span class="comment">%可以发现，背景图像提取了每一个硬币的所在区域并进行了一定的光滑化</span></span><br><span class="line"></span><br><span class="line">coins1=imsubtract(coins,background);<span class="comment">%MATLAB提供的更专业的相减函数</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(coins1);  </span><br><span class="line">title (<span class="string">'imsubtract函数相减结果'</span>)</span><br><span class="line"></span><br><span class="line">K = imabsdiff(coins,background);<span class="comment">%前景值不论正负都可以保留</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);imshow(K,[])	<span class="comment">%按K的范围比例放缩输出（扩大对比度）</span></span><br><span class="line">title (<span class="string">'imabsdiff函数相减结果'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/coin.png" style="zoom:75%;"></p>
<h1 id="图像的前景抠图与背景更换"><a href="#图像的前景抠图与背景更换" class="headerlink" title="图像的前景抠图与背景更换"></a>图像的前景抠图与背景更换</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ind = background&gt;=<span class="number">80</span>;		<span class="comment">%硬币区域背景值均大于等于80</span></span><br><span class="line"><span class="built_in">figure</span>;subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(ind)</span><br><span class="line">title(<span class="string">'获取的前景位置'</span>)</span><br><span class="line"></span><br><span class="line">coins_f = immultiply(coins,ind);	</span><br><span class="line"><span class="comment">%两个uint8与logical矩阵做图像式乘法时，*或.*均会出现错误(非double)</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);imshow(coins_f)</span><br><span class="line">title(<span class="string">'抠取的前景图像'</span>)</span><br><span class="line"></span><br><span class="line">background_new = imread(<span class="string">'nbg.png'</span>);</span><br><span class="line"><span class="comment">%这个文件MATLAB没有,可自己尝试生成一个同型的灰度背景图像</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);imshow(background_new)</span><br><span class="line">title(<span class="string">'新背景图像'</span>)</span><br><span class="line"></span><br><span class="line">coins_new = coins_f + immultiply(background_new,~ind);</span><br><span class="line"><span class="comment">%逻辑型矩阵ind做非运算后，1变成0,0变成1。因此背景部分代替无硬币区域</span></span><br><span class="line"><span class="comment">%有硬币区域使用最初coins的图像灰度，进行整合</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);imshow(coins_new)</span><br><span class="line">title(<span class="string">'新合成图像'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215105836072.png" alt="image-20201215105836072" style="zoom:67%;"></p>
<h1 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h1><p>二维离散傅里叶变换可以理解为一维离散傅里叶变换的张量积，或理解按照两个方向分别作一次一维傅里叶变换。定义:</p>
<script type="math/tex; mode=display">
F(u, v)=\sum_{x=1}^{m} \sum_{y=1}^{n} f(x, y) \mathrm{e}^{\frac{(-2 \pi j)(x-1)(u-1)}{m}+\frac{(-2 \pi j)(y-1)(v-1)}{n}}</script><p>$1 \leq u \leq m, 1 \leq v \leq n,$ $j$为虚数单位。特别的当 $(u, v)=(1,1)$ 时, $F(1,1)=\sum_{x=1}^{m} \sum_{y=1}^{n} f(x, y)$ 称为离散傅里叶变换的低频系数。<br>余系数称为高频傅里叶系数。低频系数表达了函数的区域总和。 高频系数则在不同程度刻画函数的变化情况。 回函数<code>fft2 (X)</code>可计算出矩阵或图像X的二维离散傅里叶变换<br>离散傅里叶逆变换定义</p>
<script type="math/tex; mode=display">
f(x, y)=\frac{1}{m n} \sum_{u=1}^{m} \sum_{v=1}^{n} F(u, v) \mathrm{e}^{\frac{(2 \pi j)(x-1)(u-1)}{m}+\frac{(2 \pi j)(y-1)(v-1)}{n}}</script><p>$1 \leq x \leq m, 1 \leq y \leq n,$ MATLAB对应函数<code>ifft2 (Y)​</code></p>
<p>对Cameraman图像进行二维傅里叶变换，模的最大值必为低频值，除左上角外，大值多位于四个角落。因此可以使用MATLAB函数<code>fftshift</code>来平移傅里叶变换函数将大值置于中部</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clear,close all;</span><br><span class="line">A = imread(<span class="string">'cameraman.tif'</span>);<span class="comment">%MATLAB自带的图像</span></span><br><span class="line">FA = fft2(A);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(<span class="built_in">abs</span>(FA),[<span class="number">0</span>,<span class="number">1e4</span>]),title(<span class="string">'原始傅里叶变换'</span>);</span><br><span class="line">FAS = fftshift(FA);	<span class="comment">%本身不改变FA的值，只是进行一个水平与竖直方向的平移</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(<span class="built_in">abs</span>(FAS),[<span class="number">0</span>,<span class="number">1e4</span>]),title(<span class="string">'平移傅里叶变换'</span>);</span><br><span class="line"><span class="comment">%这里1e4并不是变换的最大模，只是为了能够尽量反映傅里叶系数模的对比度</span></span><br></pre></td></tr></table></figure>
<p>傅里叶变换对于自然图像往往不具有稀疏性。对于小块亮度函数，其频谱线会集中在坐标轴，并且保持旋转不变性。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">zeros</span>(<span class="number">900</span>,<span class="number">900</span>);</span><br><span class="line">f(<span class="number">351</span>:<span class="number">648</span>,<span class="number">476</span>:<span class="number">525</span>)=<span class="number">1</span>;</span><br><span class="line">subplot(<span class="number">221</span>);imshow(f,[]);title(<span class="string">'原始图像'</span>);</span><br><span class="line"></span><br><span class="line">F=fftshift(fft2(f));</span><br><span class="line">subplot(<span class="number">222</span>);imshow(<span class="built_in">log</span>(<span class="number">1</span>+<span class="built_in">abs</span>(F)),[])	</span><br><span class="line"><span class="comment">%log(1+abs(F))进行合理比例变化，保证图谱清晰</span></span><br><span class="line"></span><br><span class="line">title(<span class="string">'原始图像的频谱'</span>);</span><br><span class="line">f=imrotate(f,<span class="number">45</span>,<span class="string">'bilinear'</span>,<span class="string">'crop'</span>); 	</span><br><span class="line"><span class="comment">%对其进行旋转，双线性，如果出格则裁剪掉的算法</span></span><br><span class="line">subplot(<span class="number">223</span>),imshow(f,[])</span><br><span class="line">title(<span class="string">'图像正向旋转45度'</span>)</span><br><span class="line"></span><br><span class="line">Fc=fftshift(fft2(f));</span><br><span class="line">subplot(<span class="number">224</span>);</span><br><span class="line">imshow(<span class="built_in">log</span>(<span class="number">1</span>+<span class="built_in">abs</span>(Fc)),[])</span><br><span class="line">title(<span class="string">'旋转后图像的频谱'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215110825731.png" alt="image-20201215110825731" style="zoom:67%;"></p>
<h1 id="二维离散余弦变换"><a href="#二维离散余弦变换" class="headerlink" title="二维离散余弦变换"></a>二维离散余弦变换</h1><ul>
<li>二维离散余弦变换与二维离散傅里叶变换类似，但不同点为余弦变换是实变换，并且更贴近于真实图像的频谱分析需求（因为真实图像在二维空间往往并不具有周期性），定义:<br>$C(u, v)=a(u) b(v) \sum_{x=1}^{m} \sum_{y=1}^{n} f(x, y) \cos \frac{(2 x-1)(u-1) \pi}{2 m} \cos \frac{(2 y-1)(v-1) \pi}{2 n}$<br>$\mathbf{1} \leq u \leq m, \mathbf{1} \leq v \leq n_{\circ}$ 其中 $a(u)=\left\{\begin{array}{l}\sqrt{\frac{1}{m}}, u=1 \\ \sqrt{\frac{2}{m}}, u \neq 1\end{array}, b(v)=\left\{\begin{array}{l}\sqrt{\frac{1}{n}}, v=1 \\ \sqrt{\frac{2}{n}}, v \neq 1\end{array}\right.\right.$<br>特别的当 $(u, v)=(1,1)$ 时, $C(1,1)=\frac{1}{\sqrt{m n}} \sum_{x=1}^{m} \sum_{y=1}^{n} f(x, y)$ 称为<strong>离散余弦变换的低频系数</strong>。其余系数称为<strong>高频余弦系数</strong>。</li>
<li>函数<code>dct2 (X)</code>可计算出矩阵或图像X的二维离散余弦变换</li>
<li>离散余弦逆变换可以类似定义，其MATLAB对应函数<code>idct2 (Y)</code></li>
</ul>
<p>实际的自然图像，大都在整体区域上不满足恒为常值，也不满足具有周期纹理状的统一分布。但是往往<strong>在局部分片上满足相应形式</strong>，因此，分片傅里叶变换或分片余弦变换就有了很大的存在和利用价值。</p>
<h1 id="图像恢复问题"><a href="#图像恢复问题" class="headerlink" title="图像恢复问题"></a>图像恢复问题</h1><h2 id="图像去高斯噪声问题"><a href="#图像去高斯噪声问题" class="headerlink" title="图像去高斯噪声问题"></a>图像去高斯噪声问题</h2><p>与信号去噪问题相似，图像去噪问题即图像对应的目标函数受到了一些未知的退化变换，得到了一幅带有噪点的不准确图像。去噪问题即利用图像的内在性质与噪声分布的特点，完成目标清晰图像的估计与获取的过程。</p>
<p>函数<code>imnoise</code>可生成各种类型的带有各种噪声的图像</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = imnoise(A,<span class="string">'gaussian'</span>,<span class="number">0</span>,<span class="number">0.05</span>);</span><br><span class="line"><span class="comment">% 对图像A添加高斯噪声，均值0，方差0.05*(255^2),与个人生成随机矩阵计算相比，imnoise可以自动将结果化为uint8型</span></span><br></pre></td></tr></table></figure>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215111338848.png" alt="image-20201215111338848" style="zoom:67%;"></p>
<h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>最简单也最直接的二维图像高斯噪声的去噪方法即为均值滤波方法，对应的MATLAB函数为<code>imfilter</code>。用法形如：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filt = <span class="number">1</span>/<span class="number">25</span> * <span class="built_in">ones</span>(<span class="number">5</span>)</span><br><span class="line">C = imfilter(B,filt,<span class="string">'symmetric'</span>,<span class="string">'same'</span>);</span><br></pre></td></tr></table></figure>
<p>解释：设立25点均值滤波的方法，即以每个像素为中心，周围$5X5$的范围的均值代替原有的含有噪声的图像函数值，这个和一元信号去噪使用<code>smooth</code>函数的原理基本相同。对称边界条件，滤波时不改变图像大小(对应<code>’same’</code>，否则为<code>’full’</code>)</p>
<p><img src="/posts/Pic/Matlab%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%20%E5%88%9D%E6%AD%A5/image-20201215111548575.png" alt="image-20201215111548575" style="zoom:67%;"></p>
<h2 id="恢复结果的衡量-峰值信噪比-PSNR"><a href="#恢复结果的衡量-峰值信噪比-PSNR" class="headerlink" title="恢复结果的衡量-峰值信噪比(PSNR)"></a>恢复结果的衡量-峰值信噪比(PSNR)</h2><p>除了直接通过肉眼观察图像质量外，基于图像函数误差定义的峰值信噪比，可以对图像的恢复质量进行数值上的分析。峰值信噪比的定义（8位无符号整型）为：</p>
<script type="math/tex; mode=display">10*\text{log}_{10}(\frac{255^2*\text{总点数}}{\sum[y-f(x)]^2})</script><p>可以注意到，峰值信噪比的值往往大于信噪比，仅取决于图像函数的绝对误差。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psnr(B,A)			<span class="comment">% 真实图像在前后均可</span></span><br><span class="line"><span class="comment">% ans = 13.8864,带有噪声的图像PSNR值较低，单位分贝dB</span></span><br><span class="line">psnr(C,A)</span><br><span class="line"><span class="comment">% ans = 21.0560,均值滤波确实减小了误差，提高了PSNR</span></span><br></pre></td></tr></table></figure>
<h2 id="椒盐噪声与图像填充问题"><a href="#椒盐噪声与图像填充问题" class="headerlink" title="椒盐噪声与图像填充问题"></a>椒盐噪声与图像填充问题</h2><p>椒盐噪声，即随机选择图像中的若干像点，将他们的值变为0（黑椒点）或255（白盐点），使其与真实值无关。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = imnoise(A,<span class="string">'salt &amp; pepper'</span>,<span class="number">0.1</span>); <span class="comment">% 将10%随机的像点转化为非黑即白的椒盐噪声</span></span><br></pre></td></tr></table></figure>
<p>椒盐噪声所在位置的直接检测方法讲就是直接找出像素值 为0与255的点，用周围像素值填充。这些信息被认定为是无效的，需要通过其他位置的灰度值来恢复这些被破坏的灰度值。因此椒盐噪声去噪本质上是一种图像填充问题(估计完全未知元素)</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind = (B==<span class="number">0</span>) | (B==<span class="number">255</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(ind(:))/<span class="built_in">numel</span>(ind)</span><br><span class="line"><span class="comment">% ans = 0.1000 噪点比例检测</span></span><br></pre></td></tr></table></figure>
<h3 id="椒盐噪声的简单恢复方法-中值滤波"><a href="#椒盐噪声的简单恢复方法-中值滤波" class="headerlink" title="椒盐噪声的简单恢复方法-中值滤波"></a>椒盐噪声的简单恢复方法-中值滤波</h3><p>因为椒盐噪声噪点周围，我们认为绝大多数的信息是准确的，因此可以在噪点周围3X3或5X5的范围内取灰度值的中位数来估计噪点的灰度，可以削弱信息缺失的影响。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C = medfilt2(B,[<span class="number">3</span> <span class="number">3</span>]); 	<span class="comment">% 3X3的中值滤波，即一个像点上下左右3X3区域内取中位数估计</span></span><br><span class="line">psnr(B,A)		       	<span class="comment">% ans = 15.0481 </span></span><br><span class="line">psnr(C,A)				<span class="comment">% ans 	= 25.8709</span></span><br><span class="line">C(~ind) = B(~ind);		<span class="comment">% 未填充区域应取消滤波效果</span></span><br><span class="line">psnr(C,A)				<span class="comment">% ans 	= 33.4267</span></span><br></pre></td></tr></table></figure>
<p><strong>图像区域填充问题与逐步填充的思想</strong></p>
<ul>
<li>图像有时候会整块的丢失或不再需要（如部分PS或美图软件中的擦除笔功能），此问题本质上也是一个图像填充问题，需要利用已知或未擦除区域对剩余区域进行估计。</li>
<li>反复进行中值滤波，真实值会渐渐渗透到填充区域内部，从而达到图像填充的理想效果。滤波半径尽量大一些</li>
</ul>
<h1 id="图像模糊"><a href="#图像模糊" class="headerlink" title="图像模糊"></a>图像模糊</h1><p><strong>卷积</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = imread(<span class="string">'XX.png'</span>);</span><br><span class="line">kernel = fspecial(<span class="string">'disk'</span>,<span class="number">10</span>);	   <span class="comment">%对焦不准模糊核，半径为10</span></span><br><span class="line">B = imfilter(A,kernel,<span class="string">'replicate'</span>); <span class="comment">%复制型边界条件,PSNR=21.05dB</span></span><br></pre></td></tr></table></figure>
<p><strong>移动模糊核</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = imread(<span class="string">'XX.png'</span>);</span><br><span class="line">kernel = fspecial(<span class="string">'motion'</span>,<span class="number">15</span>,<span class="number">90</span>);  <span class="comment">%向上平移15格的移动模糊</span></span><br><span class="line">B = imfilter(A,kernel,<span class="string">'replicate'</span>); <span class="comment">%复制型边界条件,PSNR=23.67dB</span></span><br></pre></td></tr></table></figure>
<p><strong>周期型边界条件</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = imread(<span class="string">'XX.png'</span>);</span><br><span class="line">kernel = fspecial(<span class="string">'disk'</span>,<span class="number">10</span>);		<span class="comment">%对焦不准模糊核，半径为10</span></span><br><span class="line">C = imfilter(A,kernel,<span class="string">'circular'</span>); 	<span class="comment">%周期型边界条件,PSNR=20.79dB</span></span><br></pre></td></tr></table></figure>
<p><strong>MATLAB的图像反卷积函数-<code>deconvreg</code></strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D = deconvreg(B,kernel);	<span class="comment">%复制型边界恢复效果很差,PSNR=7.79dB</span></span><br><span class="line">E = deconvreg(C,kernel);	<span class="comment">%周期型则几乎完全恢复,PSNR=28.94dB</span></span><br></pre></td></tr></table></figure>
<p><strong>MATLAB的盲反卷积函数-<code>deconvblind</code></strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F = deconvblind(B,kernel);		 </span><br><span class="line"><span class="comment">% 以kernel为初值，即使与真实的模糊核有差距，边界条件也有一些差距，仍可恢复到勉强的水平。PSNR=22.05dB</span></span><br></pre></td></tr></table></figure>
<p>可以将模糊化过程定义为函数句柄，再用<code>cgs,gmres</code>等反问题求解函数来获取较为准确的解。但由于整数化近似带来的误差所造成的的不可逆影响。结果仍然无法得到完全的清晰。<code>PSNR=27.44dB</code>，使用正则化将结果进行分片光滑的逼近可以进一步改善相应的结果。    </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://chenkai66.github.io/posts/71d7d118.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/posts/7aa9eaaf.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            matlab/Matlab概率统计与曲线拟合
          
        </div>
      </a>
    
    
      <a href="/posts/53add54c.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">matlab/Matlab数字信号与声音处理</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "TQy5bHTePagP10u5BBsesx61-gzGzoHsz",
    app_key: "O6UyJYxBFgMKQMjktBh4KGad",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> chenk
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 帅气的CK本尊 强力驱动
        
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="言念君子"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haruto"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>